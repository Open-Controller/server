// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.15.7
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `OpenControllerLib.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct House {
    // message fields
    display_name: ::std::option::Option<::std::string::String>,
    id: ::std::option::Option<::std::string::String>,
    pub rooms: ::std::vec::Vec<Room>,
    pub devices: ::std::vec::Vec<Device>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a House {
    fn default() -> &'a House {
        <House as ::protobuf::Message>::default_instance()
    }
}

impl House {
    pub fn new() -> House {
        ::std::default::Default::default()
    }

    // required string display_name = 1;

    pub fn get_display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string id = 2;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "display_name",
            |m: &House| { &m.display_name },
            |m: &mut House| { &mut m.display_name },
            House::get_display_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &House| { &m.id },
            |m: &mut House| { &mut m.id },
            House::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rooms",
            |m: &House| { &m.rooms },
            |m: &mut House| { &mut m.rooms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &House| { &m.devices },
            |m: &mut House| { &mut m.devices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<House>(
            "House",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for House {
    fn is_initialized(&self) -> bool {
        if self.display_name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        for v in &self.rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.devices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.rooms)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.devices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.rooms {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> House {
        House::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static House {
        static instance: House = House {
            display_name: ::std::option::Option::None,
            id: ::std::option::Option::None,
            rooms: ::std::vec::Vec::new(),
            devices: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for House {
    fn clear(&mut self) {
        self.display_name = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.rooms.clear();
        self.devices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for House {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for House {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Room {
    // message fields
    display_name: ::std::option::Option<::std::string::String>,
    id: ::std::option::Option<::std::string::String>,
    pub controllers: ::std::vec::Vec<Controller>,
    icon: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Icon>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Room {
    fn default() -> &'a Room {
        <Room as ::protobuf::Message>::default_instance()
    }
}

impl Room {
    pub fn new() -> Room {
        ::std::default::Default::default()
    }

    // required string display_name = 1;

    pub fn get_display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string id = 2;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .model.Icon icon = 4;

    pub fn get_icon(&self) -> Icon {
        match self.icon {
            Some(e) => e.enum_value_or(Icon::ROOM),
            None => Icon::ROOM,
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: Icon) {
        self.icon = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "display_name",
            |m: &Room| { &m.display_name },
            |m: &mut Room| { &mut m.display_name },
            Room::get_display_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &Room| { &m.id },
            |m: &mut Room| { &mut m.id },
            Room::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controllers",
            |m: &Room| { &m.controllers },
            |m: &mut Room| { &mut m.controllers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Icon>(
            "icon",
            |m: &Room| { &m.icon },
            |m: &mut Room| { &mut m.icon },
            Icon::ROOM,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Room>(
            "Room",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for Room {
    fn is_initialized(&self) -> bool {
        if self.display_name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        for v in &self.controllers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.controllers)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.icon = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.controllers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.icon {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.controllers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.icon {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Room {
        Room::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static Room {
        static instance: Room = Room {
            display_name: ::std::option::Option::None,
            id: ::std::option::Option::None,
            controllers: ::std::vec::Vec::new(),
            icon: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Room {
    fn clear(&mut self) {
        self.display_name = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.controllers.clear();
        self.icon = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Room {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Room {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Controller {
    // message fields
    display_name: ::std::option::Option<::std::string::String>,
    id: ::std::option::Option<::std::string::String>,
    pub widgets: ::std::vec::Vec<Widget>,
    brand_color: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Controller {
    fn default() -> &'a Controller {
        <Controller as ::protobuf::Message>::default_instance()
    }
}

impl Controller {
    pub fn new() -> Controller {
        ::std::default::Default::default()
    }

    // required string display_name = 1;

    pub fn get_display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string id = 2;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string brand_color = 4;

    pub fn get_brand_color(&self) -> &str {
        match self.brand_color.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_brand_color(&mut self) {
        self.brand_color = ::std::option::Option::None;
    }

    pub fn has_brand_color(&self) -> bool {
        self.brand_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brand_color(&mut self, v: ::std::string::String) {
        self.brand_color = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brand_color(&mut self) -> &mut ::std::string::String {
        if self.brand_color.is_none() {
            self.brand_color = ::std::option::Option::Some(::std::string::String::new());
        }
        self.brand_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_brand_color(&mut self) -> ::std::string::String {
        self.brand_color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "display_name",
            |m: &Controller| { &m.display_name },
            |m: &mut Controller| { &mut m.display_name },
            Controller::get_display_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &Controller| { &m.id },
            |m: &mut Controller| { &mut m.id },
            Controller::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "widgets",
            |m: &Controller| { &m.widgets },
            |m: &mut Controller| { &mut m.widgets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "brand_color",
            |m: &Controller| { &m.brand_color },
            |m: &mut Controller| { &mut m.brand_color },
            Controller::get_brand_color,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Controller>(
            "Controller",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for Controller {
    fn is_initialized(&self) -> bool {
        if self.display_name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        for v in &self.widgets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.widgets)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.brand_color = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.widgets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.brand_color.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.widgets {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.brand_color.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Controller {
        Controller::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static Controller {
        static instance: Controller = Controller {
            display_name: ::std::option::Option::None,
            id: ::std::option::Option::None,
            widgets: ::std::vec::Vec::new(),
            brand_color: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Controller {
    fn clear(&mut self) {
        self.display_name = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.widgets.clear();
        self.brand_color = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Controller {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Controller {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    id: ::std::option::Option<::std::string::String>,
    pub lambdas: ::std::vec::Vec<Lambda>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // required string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &Device| { &m.id },
            |m: &mut Device| { &mut m.id },
            Device::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lambdas",
            |m: &Device| { &m.lambdas },
            |m: &mut Device| { &mut m.lambdas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
            "Device",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.lambdas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.lambdas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.lambdas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.lambdas {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static Device {
        static instance: Device = Device {
            id: ::std::option::Option::None,
            lambdas: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.lambdas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Widget {
    // message fields
    expand: ::std::option::Option<bool>,
    // message oneof groups
    pub inner: ::std::option::Option<widget::Inner>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Widget {
    fn default() -> &'a Widget {
        <Widget as ::protobuf::Message>::default_instance()
    }
}

impl Widget {
    pub fn new() -> Widget {
        ::std::default::Default::default()
    }

    // optional bool expand = 1;

    pub fn get_expand(&self) -> bool {
        self.expand.unwrap_or(false)
    }

    pub fn clear_expand(&mut self) {
        self.expand = ::std::option::Option::None;
    }

    pub fn has_expand(&self) -> bool {
        self.expand.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expand(&mut self, v: bool) {
        self.expand = ::std::option::Option::Some(v);
    }

    // optional .model.Button button = 2;

    pub fn get_button(&self) -> &Button {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::button(ref v)) => v,
            _ => <Button as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_button(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::button(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: Button) {
        self.inner = ::std::option::Option::Some(widget::Inner::button(v))
    }

    // Mutable pointer to the field.
    pub fn mut_button(&mut self) -> &mut Button {
        if let ::std::option::Option::Some(widget::Inner::button(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::button(Button::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::button(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_button(&mut self) -> Button {
        if self.has_button() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::button(v)) => v,
                _ => panic!(),
            }
        } else {
            Button::new()
        }
    }

    // optional .model.Row row = 3;

    pub fn get_row(&self) -> &Row {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::row(ref v)) => v,
            _ => <Row as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_row(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_row(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::row(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: Row) {
        self.inner = ::std::option::Option::Some(widget::Inner::row(v))
    }

    // Mutable pointer to the field.
    pub fn mut_row(&mut self) -> &mut Row {
        if let ::std::option::Option::Some(widget::Inner::row(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::row(Row::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::row(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_row(&mut self) -> Row {
        if self.has_row() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::row(v)) => v,
                _ => panic!(),
            }
        } else {
            Row::new()
        }
    }

    // optional .model.Column column = 4;

    pub fn get_column(&self) -> &Column {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::column(ref v)) => v,
            _ => <Column as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_column(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_column(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::column(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: Column) {
        self.inner = ::std::option::Option::Some(widget::Inner::column(v))
    }

    // Mutable pointer to the field.
    pub fn mut_column(&mut self) -> &mut Column {
        if let ::std::option::Option::Some(widget::Inner::column(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::column(Column::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::column(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_column(&mut self) -> Column {
        if self.has_column() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::column(v)) => v,
                _ => panic!(),
            }
        } else {
            Column::new()
        }
    }

    // optional .model.ArrowLayout arrow_layout = 5;

    pub fn get_arrow_layout(&self) -> &ArrowLayout {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::arrow_layout(ref v)) => v,
            _ => <ArrowLayout as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_arrow_layout(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_arrow_layout(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::arrow_layout(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arrow_layout(&mut self, v: ArrowLayout) {
        self.inner = ::std::option::Option::Some(widget::Inner::arrow_layout(v))
    }

    // Mutable pointer to the field.
    pub fn mut_arrow_layout(&mut self) -> &mut ArrowLayout {
        if let ::std::option::Option::Some(widget::Inner::arrow_layout(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::arrow_layout(ArrowLayout::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::arrow_layout(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arrow_layout(&mut self) -> ArrowLayout {
        if self.has_arrow_layout() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::arrow_layout(v)) => v,
                _ => panic!(),
            }
        } else {
            ArrowLayout::new()
        }
    }

    // optional .model.Space space = 6;

    pub fn get_space(&self) -> &Space {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::space(ref v)) => v,
            _ => <Space as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_space(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_space(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::space(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: Space) {
        self.inner = ::std::option::Option::Some(widget::Inner::space(v))
    }

    // Mutable pointer to the field.
    pub fn mut_space(&mut self) -> &mut Space {
        if let ::std::option::Option::Some(widget::Inner::space(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::space(Space::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::space(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_space(&mut self) -> Space {
        if self.has_space() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::space(v)) => v,
                _ => panic!(),
            }
        } else {
            Space::new()
        }
    }

    // optional .model.TextInput text_input = 7;

    pub fn get_text_input(&self) -> &TextInput {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::text_input(ref v)) => v,
            _ => <TextInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_text_input(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_text_input(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::text_input(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text_input(&mut self, v: TextInput) {
        self.inner = ::std::option::Option::Some(widget::Inner::text_input(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text_input(&mut self) -> &mut TextInput {
        if let ::std::option::Option::Some(widget::Inner::text_input(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::text_input(TextInput::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::text_input(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text_input(&mut self) -> TextInput {
        if self.has_text_input() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::text_input(v)) => v,
                _ => panic!(),
            }
        } else {
            TextInput::new()
        }
    }

    // optional .model.SwipePad swipe_pad = 8;

    pub fn get_swipe_pad(&self) -> &SwipePad {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::swipe_pad(ref v)) => v,
            _ => <SwipePad as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_swipe_pad(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_swipe_pad(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::swipe_pad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_swipe_pad(&mut self, v: SwipePad) {
        self.inner = ::std::option::Option::Some(widget::Inner::swipe_pad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_swipe_pad(&mut self) -> &mut SwipePad {
        if let ::std::option::Option::Some(widget::Inner::swipe_pad(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::swipe_pad(SwipePad::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::swipe_pad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_swipe_pad(&mut self) -> SwipePad {
        if self.has_swipe_pad() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::swipe_pad(v)) => v,
                _ => panic!(),
            }
        } else {
            SwipePad::new()
        }
    }

    // optional .model.MenuButton menu_button = 9;

    pub fn get_menu_button(&self) -> &MenuButton {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::menu_button(ref v)) => v,
            _ => <MenuButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_menu_button(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_menu_button(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(widget::Inner::menu_button(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_menu_button(&mut self, v: MenuButton) {
        self.inner = ::std::option::Option::Some(widget::Inner::menu_button(v))
    }

    // Mutable pointer to the field.
    pub fn mut_menu_button(&mut self) -> &mut MenuButton {
        if let ::std::option::Option::Some(widget::Inner::menu_button(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(widget::Inner::menu_button(MenuButton::new()));
        }
        match self.inner {
            ::std::option::Option::Some(widget::Inner::menu_button(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_menu_button(&mut self) -> MenuButton {
        if self.has_menu_button() {
            match self.inner.take() {
                ::std::option::Option::Some(widget::Inner::menu_button(v)) => v,
                _ => panic!(),
            }
        } else {
            MenuButton::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "expand",
            |m: &Widget| { &m.expand },
            |m: &mut Widget| { &mut m.expand },
            Widget::get_expand,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Button>(
            "button",
            Widget::has_button,
            Widget::get_button,
            Widget::mut_button,
            Widget::set_button,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Row>(
            "row",
            Widget::has_row,
            Widget::get_row,
            Widget::mut_row,
            Widget::set_row,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Column>(
            "column",
            Widget::has_column,
            Widget::get_column,
            Widget::mut_column,
            Widget::set_column,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ArrowLayout>(
            "arrow_layout",
            Widget::has_arrow_layout,
            Widget::get_arrow_layout,
            Widget::mut_arrow_layout,
            Widget::set_arrow_layout,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Space>(
            "space",
            Widget::has_space,
            Widget::get_space,
            Widget::mut_space,
            Widget::set_space,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TextInput>(
            "text_input",
            Widget::has_text_input,
            Widget::get_text_input,
            Widget::mut_text_input,
            Widget::set_text_input,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwipePad>(
            "swipe_pad",
            Widget::has_swipe_pad,
            Widget::get_swipe_pad,
            Widget::mut_swipe_pad,
            Widget::set_swipe_pad,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MenuButton>(
            "menu_button",
            Widget::has_menu_button,
            Widget::get_menu_button,
            Widget::mut_menu_button,
            Widget::set_menu_button,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Widget>(
            "Widget",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for Widget {
    fn is_initialized(&self) -> bool {
        if let Some(widget::Inner::button(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(widget::Inner::row(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(widget::Inner::column(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(widget::Inner::arrow_layout(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(widget::Inner::space(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(widget::Inner::text_input(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(widget::Inner::swipe_pad(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(widget::Inner::menu_button(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expand = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::button(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::row(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::column(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::arrow_layout(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::space(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::text_input(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::swipe_pad(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(widget::Inner::menu_button(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.expand {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &widget::Inner::button(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &widget::Inner::row(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &widget::Inner::column(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &widget::Inner::arrow_layout(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &widget::Inner::space(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &widget::Inner::text_input(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &widget::Inner::swipe_pad(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &widget::Inner::menu_button(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.expand {
            os.write_bool(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &widget::Inner::button(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &widget::Inner::row(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &widget::Inner::column(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &widget::Inner::arrow_layout(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &widget::Inner::space(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &widget::Inner::text_input(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &widget::Inner::swipe_pad(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &widget::Inner::menu_button(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Widget {
        Widget::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static Widget {
        static instance: Widget = Widget {
            expand: ::std::option::Option::None,
            inner: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Widget {
    fn clear(&mut self) {
        self.expand = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Widget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Widget {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Widget`
pub mod widget {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Inner {
        button(super::Button),
        row(super::Row),
        column(super::Column),
        arrow_layout(super::ArrowLayout),
        space(super::Space),
        text_input(super::TextInput),
        swipe_pad(super::SwipePad),
        menu_button(super::MenuButton),
    }

    impl ::protobuf::Oneof for Inner {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Button {
    // message fields
    pub on_click: ::protobuf::MessageField<Lambda>,
    icon: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Icon>>,
    text: ::std::option::Option<::std::string::String>,
    size: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Size>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Button {
    fn default() -> &'a Button {
        <Button as ::protobuf::Message>::default_instance()
    }
}

impl Button {
    pub fn new() -> Button {
        ::std::default::Default::default()
    }

    // optional .model.Icon icon = 2;

    pub fn get_icon(&self) -> Icon {
        match self.icon {
            Some(e) => e.enum_value_or(Icon::STAR),
            None => Icon::STAR,
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: Icon) {
        self.icon = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // required string text = 3;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .model.Size size = 4;

    pub fn get_size(&self) -> Size {
        match self.size {
            Some(e) => e.enum_value_or(Size::SMALL),
            None => Size::SMALL,
        }
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: Size) {
        self.size = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_click",
            |m: &Button| { &m.on_click },
            |m: &mut Button| { &mut m.on_click },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Icon>(
            "icon",
            |m: &Button| { &m.icon },
            |m: &mut Button| { &mut m.icon },
            Icon::STAR,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "text",
            |m: &Button| { &m.text },
            |m: &mut Button| { &mut m.text },
            Button::get_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Size>(
            "size",
            |m: &Button| { &m.size },
            |m: &mut Button| { &mut m.size },
            Size::SMALL,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Button>(
            "Button",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for Button {
    fn is_initialized(&self) -> bool {
        if self.on_click.is_none() {
            return false;
        }
        if self.text.is_none() {
            return false;
        }
        for v in &self.on_click {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_click)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.icon = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.size = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.on_click.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.icon {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.on_click.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.icon {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Button {
        Button::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static Button {
        static instance: Button = Button {
            on_click: ::protobuf::MessageField::none(),
            icon: ::std::option::Option::None,
            text: ::std::option::Option::None,
            size: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Button {
    fn clear(&mut self) {
        self.on_click.clear();
        self.icon = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Button {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Button {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Row {
    // message fields
    pub children: ::std::vec::Vec<Widget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Row {
    fn default() -> &'a Row {
        <Row as ::protobuf::Message>::default_instance()
    }
}

impl Row {
    pub fn new() -> Row {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "children",
            |m: &Row| { &m.children },
            |m: &mut Row| { &mut m.children },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Row>(
            "Row",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for Row {
    fn is_initialized(&self) -> bool {
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.children)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Row {
        Row::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static Row {
        static instance: Row = Row {
            children: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Row {
    fn clear(&mut self) {
        self.children.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Row {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Column {
    // message fields
    pub children: ::std::vec::Vec<Widget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Column {
    fn default() -> &'a Column {
        <Column as ::protobuf::Message>::default_instance()
    }
}

impl Column {
    pub fn new() -> Column {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "children",
            |m: &Column| { &m.children },
            |m: &mut Column| { &mut m.children },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Column>(
            "Column",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for Column {
    fn is_initialized(&self) -> bool {
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.children)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Column {
        Column::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static Column {
        static instance: Column = Column {
            children: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Column {
    fn clear(&mut self) {
        self.children.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Column {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Column {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct ArrowLayout {
    // message fields
    pub top: ::protobuf::MessageField<Widget>,
    pub bottom: ::protobuf::MessageField<Widget>,
    pub left: ::protobuf::MessageField<Widget>,
    pub right: ::protobuf::MessageField<Widget>,
    pub center: ::protobuf::MessageField<Widget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArrowLayout {
    fn default() -> &'a ArrowLayout {
        <ArrowLayout as ::protobuf::Message>::default_instance()
    }
}

impl ArrowLayout {
    pub fn new() -> ArrowLayout {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Widget>(
            "top",
            |m: &ArrowLayout| { &m.top },
            |m: &mut ArrowLayout| { &mut m.top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Widget>(
            "bottom",
            |m: &ArrowLayout| { &m.bottom },
            |m: &mut ArrowLayout| { &mut m.bottom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Widget>(
            "left",
            |m: &ArrowLayout| { &m.left },
            |m: &mut ArrowLayout| { &mut m.left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Widget>(
            "right",
            |m: &ArrowLayout| { &m.right },
            |m: &mut ArrowLayout| { &mut m.right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Widget>(
            "center",
            |m: &ArrowLayout| { &m.center },
            |m: &mut ArrowLayout| { &mut m.center },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArrowLayout>(
            "ArrowLayout",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for ArrowLayout {
    fn is_initialized(&self) -> bool {
        if self.top.is_none() {
            return false;
        }
        if self.bottom.is_none() {
            return false;
        }
        if self.left.is_none() {
            return false;
        }
        if self.right.is_none() {
            return false;
        }
        if self.center.is_none() {
            return false;
        }
        for v in &self.top {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bottom {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.center {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.top)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.bottom)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.left)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.right)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.center)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.top.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.bottom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.center.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.top.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.center.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ArrowLayout {
        ArrowLayout::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static ArrowLayout {
        static instance: ArrowLayout = ArrowLayout {
            top: ::protobuf::MessageField::none(),
            bottom: ::protobuf::MessageField::none(),
            left: ::protobuf::MessageField::none(),
            right: ::protobuf::MessageField::none(),
            center: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ArrowLayout {
    fn clear(&mut self) {
        self.top.clear();
        self.bottom.clear();
        self.left.clear();
        self.right.clear();
        self.center.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArrowLayout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArrowLayout {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct SwipePad {
    // message fields
    pub on_swipe_up: ::protobuf::MessageField<Lambda>,
    pub on_swipe_down: ::protobuf::MessageField<Lambda>,
    pub on_swipe_left: ::protobuf::MessageField<Lambda>,
    pub on_swipe_right: ::protobuf::MessageField<Lambda>,
    pub on_click: ::protobuf::MessageField<Lambda>,
    pub on_bottom_increase: ::protobuf::MessageField<Lambda>,
    pub on_bottom_decrease: ::protobuf::MessageField<Lambda>,
    pub on_bottom_click: ::protobuf::MessageField<Lambda>,
    bottom_increase_icon: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Icon>>,
    bottom_decrease_icon: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Icon>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwipePad {
    fn default() -> &'a SwipePad {
        <SwipePad as ::protobuf::Message>::default_instance()
    }
}

impl SwipePad {
    pub fn new() -> SwipePad {
        ::std::default::Default::default()
    }

    // optional .model.Icon bottom_increase_icon = 9;

    pub fn get_bottom_increase_icon(&self) -> Icon {
        match self.bottom_increase_icon {
            Some(e) => e.enum_value_or(Icon::STAR),
            None => Icon::STAR,
        }
    }

    pub fn clear_bottom_increase_icon(&mut self) {
        self.bottom_increase_icon = ::std::option::Option::None;
    }

    pub fn has_bottom_increase_icon(&self) -> bool {
        self.bottom_increase_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom_increase_icon(&mut self, v: Icon) {
        self.bottom_increase_icon = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .model.Icon bottom_decrease_icon = 10;

    pub fn get_bottom_decrease_icon(&self) -> Icon {
        match self.bottom_decrease_icon {
            Some(e) => e.enum_value_or(Icon::STAR),
            None => Icon::STAR,
        }
    }

    pub fn clear_bottom_decrease_icon(&mut self) {
        self.bottom_decrease_icon = ::std::option::Option::None;
    }

    pub fn has_bottom_decrease_icon(&self) -> bool {
        self.bottom_decrease_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom_decrease_icon(&mut self, v: Icon) {
        self.bottom_decrease_icon = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_swipe_up",
            |m: &SwipePad| { &m.on_swipe_up },
            |m: &mut SwipePad| { &mut m.on_swipe_up },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_swipe_down",
            |m: &SwipePad| { &m.on_swipe_down },
            |m: &mut SwipePad| { &mut m.on_swipe_down },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_swipe_left",
            |m: &SwipePad| { &m.on_swipe_left },
            |m: &mut SwipePad| { &mut m.on_swipe_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_swipe_right",
            |m: &SwipePad| { &m.on_swipe_right },
            |m: &mut SwipePad| { &mut m.on_swipe_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_click",
            |m: &SwipePad| { &m.on_click },
            |m: &mut SwipePad| { &mut m.on_click },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_bottom_increase",
            |m: &SwipePad| { &m.on_bottom_increase },
            |m: &mut SwipePad| { &mut m.on_bottom_increase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_bottom_decrease",
            |m: &SwipePad| { &m.on_bottom_decrease },
            |m: &mut SwipePad| { &mut m.on_bottom_decrease },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_bottom_click",
            |m: &SwipePad| { &m.on_bottom_click },
            |m: &mut SwipePad| { &mut m.on_bottom_click },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Icon>(
            "bottom_increase_icon",
            |m: &SwipePad| { &m.bottom_increase_icon },
            |m: &mut SwipePad| { &mut m.bottom_increase_icon },
            Icon::STAR,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Icon>(
            "bottom_decrease_icon",
            |m: &SwipePad| { &m.bottom_decrease_icon },
            |m: &mut SwipePad| { &mut m.bottom_decrease_icon },
            Icon::STAR,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwipePad>(
            "SwipePad",
            9,
            fields,
        )
    }
}

impl ::protobuf::Message for SwipePad {
    fn is_initialized(&self) -> bool {
        if self.on_swipe_up.is_none() {
            return false;
        }
        if self.on_swipe_down.is_none() {
            return false;
        }
        if self.on_swipe_left.is_none() {
            return false;
        }
        if self.on_swipe_right.is_none() {
            return false;
        }
        if self.on_click.is_none() {
            return false;
        }
        for v in &self.on_swipe_up {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_swipe_down {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_swipe_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_swipe_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_click {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_bottom_increase {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_bottom_decrease {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_bottom_click {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_swipe_up)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_swipe_down)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_swipe_left)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_swipe_right)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_click)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_bottom_increase)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_bottom_decrease)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_bottom_click)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bottom_increase_icon = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bottom_decrease_icon = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.on_swipe_up.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.on_swipe_down.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.on_swipe_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.on_swipe_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.on_click.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.on_bottom_increase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.on_bottom_decrease.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.on_bottom_click.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.bottom_increase_icon {
            my_size += ::protobuf::rt::enum_or_unknown_size(9, v);
        }
        if let Some(v) = self.bottom_decrease_icon {
            my_size += ::protobuf::rt::enum_or_unknown_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.on_swipe_up.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.on_swipe_down.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.on_swipe_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.on_swipe_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.on_click.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.on_bottom_increase.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.on_bottom_decrease.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.on_bottom_click.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.bottom_increase_icon {
            os.write_enum(9, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bottom_decrease_icon {
            os.write_enum(10, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SwipePad {
        SwipePad::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 9)
    }

    fn default_instance() -> &'static SwipePad {
        static instance: SwipePad = SwipePad {
            on_swipe_up: ::protobuf::MessageField::none(),
            on_swipe_down: ::protobuf::MessageField::none(),
            on_swipe_left: ::protobuf::MessageField::none(),
            on_swipe_right: ::protobuf::MessageField::none(),
            on_click: ::protobuf::MessageField::none(),
            on_bottom_increase: ::protobuf::MessageField::none(),
            on_bottom_decrease: ::protobuf::MessageField::none(),
            on_bottom_click: ::protobuf::MessageField::none(),
            bottom_increase_icon: ::std::option::Option::None,
            bottom_decrease_icon: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SwipePad {
    fn clear(&mut self) {
        self.on_swipe_up.clear();
        self.on_swipe_down.clear();
        self.on_swipe_left.clear();
        self.on_swipe_right.clear();
        self.on_click.clear();
        self.on_bottom_increase.clear();
        self.on_bottom_decrease.clear();
        self.on_bottom_click.clear();
        self.bottom_increase_icon = ::std::option::Option::None;
        self.bottom_decrease_icon = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwipePad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwipePad {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct TextInput {
    // message fields
    pub on_input: ::protobuf::MessageField<Lambda>,
    text: ::std::option::Option<::std::string::String>,
    icon: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Icon>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextInput {
    fn default() -> &'a TextInput {
        <TextInput as ::protobuf::Message>::default_instance()
    }
}

impl TextInput {
    pub fn new() -> TextInput {
        ::std::default::Default::default()
    }

    // required string text = 3;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .model.Icon icon = 2;

    pub fn get_icon(&self) -> Icon {
        match self.icon {
            Some(e) => e.enum_value_or(Icon::STAR),
            None => Icon::STAR,
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: Icon) {
        self.icon = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "on_input",
            |m: &TextInput| { &m.on_input },
            |m: &mut TextInput| { &mut m.on_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "text",
            |m: &TextInput| { &m.text },
            |m: &mut TextInput| { &mut m.text },
            TextInput::get_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Icon>(
            "icon",
            |m: &TextInput| { &m.icon },
            |m: &mut TextInput| { &mut m.icon },
            Icon::STAR,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextInput>(
            "TextInput",
            10,
            fields,
        )
    }
}

impl ::protobuf::Message for TextInput {
    fn is_initialized(&self) -> bool {
        if self.on_input.is_none() {
            return false;
        }
        if self.text.is_none() {
            return false;
        }
        for v in &self.on_input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.on_input)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.icon = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.on_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.icon {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.on_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.icon {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TextInput {
        TextInput::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static TextInput {
        static instance: TextInput = TextInput {
            on_input: ::protobuf::MessageField::none(),
            text: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TextInput {
    fn clear(&mut self) {
        self.on_input.clear();
        self.text = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextInput {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct TextInputAction {
    // message oneof groups
    pub inner: ::std::option::Option<text_input_action::Inner>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextInputAction {
    fn default() -> &'a TextInputAction {
        <TextInputAction as ::protobuf::Message>::default_instance()
    }
}

impl TextInputAction {
    pub fn new() -> TextInputAction {
        ::std::default::Default::default()
    }

    // optional string char = 1;

    pub fn get_char(&self) -> &str {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::char(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_char(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_char(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::char(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_char(&mut self, v: ::std::string::String) {
        self.inner = ::std::option::Option::Some(text_input_action::Inner::char(v))
    }

    // Mutable pointer to the field.
    pub fn mut_char(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(text_input_action::Inner::char(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(text_input_action::Inner::char(::std::string::String::new()));
        }
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::char(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_char(&mut self) -> ::std::string::String {
        if self.has_char() {
            match self.inner.take() {
                ::std::option::Option::Some(text_input_action::Inner::char(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bool backspace = 2;

    pub fn get_backspace(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::backspace(v)) => v,
            _ => false,
        }
    }

    pub fn clear_backspace(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_backspace(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::backspace(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backspace(&mut self, v: bool) {
        self.inner = ::std::option::Option::Some(text_input_action::Inner::backspace(v))
    }

    // optional bool cursor_left = 3;

    pub fn get_cursor_left(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::cursor_left(v)) => v,
            _ => false,
        }
    }

    pub fn clear_cursor_left(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_cursor_left(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::cursor_left(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_left(&mut self, v: bool) {
        self.inner = ::std::option::Option::Some(text_input_action::Inner::cursor_left(v))
    }

    // optional bool cursor_right = 4;

    pub fn get_cursor_right(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::cursor_right(v)) => v,
            _ => false,
        }
    }

    pub fn clear_cursor_right(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_cursor_right(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(text_input_action::Inner::cursor_right(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_right(&mut self, v: bool) {
        self.inner = ::std::option::Option::Some(text_input_action::Inner::cursor_right(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "char",
            TextInputAction::has_char,
            TextInputAction::get_char,
            TextInputAction::set_char,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "backspace",
            TextInputAction::has_backspace,
            TextInputAction::get_backspace,
            TextInputAction::set_backspace,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cursor_left",
            TextInputAction::has_cursor_left,
            TextInputAction::get_cursor_left,
            TextInputAction::set_cursor_left,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cursor_right",
            TextInputAction::has_cursor_right,
            TextInputAction::get_cursor_right,
            TextInputAction::set_cursor_right,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextInputAction>(
            "TextInputAction",
            11,
            fields,
        )
    }
}

impl ::protobuf::Message for TextInputAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(text_input_action::Inner::char(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(text_input_action::Inner::backspace(is.read_bool()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(text_input_action::Inner::cursor_left(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(text_input_action::Inner::cursor_right(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &text_input_action::Inner::char(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &text_input_action::Inner::backspace(v) => {
                    my_size += 2;
                },
                &text_input_action::Inner::cursor_left(v) => {
                    my_size += 2;
                },
                &text_input_action::Inner::cursor_right(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &text_input_action::Inner::char(ref v) => {
                    os.write_string(1, v)?;
                },
                &text_input_action::Inner::backspace(v) => {
                    os.write_bool(2, v)?;
                },
                &text_input_action::Inner::cursor_left(v) => {
                    os.write_bool(3, v)?;
                },
                &text_input_action::Inner::cursor_right(v) => {
                    os.write_bool(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TextInputAction {
        TextInputAction::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 11)
    }

    fn default_instance() -> &'static TextInputAction {
        static instance: TextInputAction = TextInputAction {
            inner: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TextInputAction {
    fn clear(&mut self) {
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextInputAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextInputAction {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TextInputAction`
pub mod text_input_action {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Inner {
        char(::std::string::String),
        backspace(bool),
        cursor_left(bool),
        cursor_right(bool),
    }

    impl ::protobuf::Oneof for Inner {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MenuButton {
    // message fields
    pub content: ::std::vec::Vec<Widget>,
    text: ::std::option::Option<::std::string::String>,
    icon: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Icon>>,
    size: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<Size>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a MenuButton {
    fn default() -> &'a MenuButton {
        <MenuButton as ::protobuf::Message>::default_instance()
    }
}

impl MenuButton {
    pub fn new() -> MenuButton {
        ::std::default::Default::default()
    }

    // required string text = 2;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .model.Icon icon = 3;

    pub fn get_icon(&self) -> Icon {
        match self.icon {
            Some(e) => e.enum_value_or(Icon::STAR),
            None => Icon::STAR,
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: Icon) {
        self.icon = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .model.Size size = 4;

    pub fn get_size(&self) -> Size {
        match self.size {
            Some(e) => e.enum_value_or(Size::SMALL),
            None => Size::SMALL,
        }
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: Size) {
        self.size = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content",
            |m: &MenuButton| { &m.content },
            |m: &mut MenuButton| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "text",
            |m: &MenuButton| { &m.text },
            |m: &mut MenuButton| { &mut m.text },
            MenuButton::get_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Icon>(
            "icon",
            |m: &MenuButton| { &m.icon },
            |m: &mut MenuButton| { &mut m.icon },
            Icon::STAR,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, Size>(
            "size",
            |m: &MenuButton| { &m.size },
            |m: &mut MenuButton| { &mut m.size },
            Size::SMALL,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MenuButton>(
            "MenuButton",
            12,
            fields,
        )
    }
}

impl ::protobuf::Message for MenuButton {
    fn is_initialized(&self) -> bool {
        if self.text.is_none() {
            return false;
        }
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.content)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.icon = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.size = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.content {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.icon {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.content {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.icon {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.size {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> MenuButton {
        MenuButton::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 12)
    }

    fn default_instance() -> &'static MenuButton {
        static instance: MenuButton = MenuButton {
            content: ::std::vec::Vec::new(),
            text: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            size: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for MenuButton {
    fn clear(&mut self) {
        self.content.clear();
        self.text = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MenuButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MenuButton {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Space {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Space {
    fn default() -> &'a Space {
        <Space as ::protobuf::Message>::default_instance()
    }
}

impl Space {
    pub fn new() -> Space {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Space>(
            "Space",
            13,
            fields,
        )
    }
}

impl ::protobuf::Message for Space {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Space {
        Space::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 13)
    }

    fn default_instance() -> &'static Space {
        static instance: Space = Space {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Space {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Space {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Space {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Lambda {
    // message fields
    id: ::std::option::Option<::std::string::String>,
    pub args: ::std::vec::Vec<::std::string::String>,
    // message oneof groups
    pub inner: ::std::option::Option<lambda::Inner>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Lambda {
    fn default() -> &'a Lambda {
        <Lambda as ::protobuf::Message>::default_instance()
    }
}

impl Lambda {
    pub fn new() -> Lambda {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .model.HttpFunc http = 3;

    pub fn get_http(&self) -> &HttpFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::http(ref v)) => v,
            _ => <HttpFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_http(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_http(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::http(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HttpFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::http(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http(&mut self) -> &mut HttpFunc {
        if let ::std::option::Option::Some(lambda::Inner::http(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::http(HttpFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::http(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http(&mut self) -> HttpFunc {
        if self.has_http() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::http(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpFunc::new()
        }
    }

    // optional .model.TCPFunc tcp = 4;

    pub fn get_tcp(&self) -> &TCPFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::tcp(ref v)) => v,
            _ => <TCPFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tcp(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_tcp(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::tcp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tcp(&mut self, v: TCPFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::tcp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tcp(&mut self) -> &mut TCPFunc {
        if let ::std::option::Option::Some(lambda::Inner::tcp(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::tcp(TCPFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::tcp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tcp(&mut self) -> TCPFunc {
        if self.has_tcp() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::tcp(v)) => v,
                _ => panic!(),
            }
        } else {
            TCPFunc::new()
        }
    }

    // optional .model.MacroFunc macro = 5;

    pub fn get_field_macro(&self) -> &MacroFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::field_macro(ref v)) => v,
            _ => <MacroFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_field_macro(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_field_macro(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::field_macro(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_macro(&mut self, v: MacroFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::field_macro(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_macro(&mut self) -> &mut MacroFunc {
        if let ::std::option::Option::Some(lambda::Inner::field_macro(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::field_macro(MacroFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::field_macro(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_macro(&mut self) -> MacroFunc {
        if self.has_field_macro() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::field_macro(v)) => v,
                _ => panic!(),
            }
        } else {
            MacroFunc::new()
        }
    }

    // optional .model.DelayFunc delay = 6;

    pub fn get_delay(&self) -> &DelayFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::delay(ref v)) => v,
            _ => <DelayFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delay(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::delay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: DelayFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::delay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delay(&mut self) -> &mut DelayFunc {
        if let ::std::option::Option::Some(lambda::Inner::delay(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::delay(DelayFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::delay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delay(&mut self) -> DelayFunc {
        if self.has_delay() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::delay(v)) => v,
                _ => panic!(),
            }
        } else {
            DelayFunc::new()
        }
    }

    // optional .model.RefFunc ref = 7;

    pub fn get_field_ref(&self) -> &RefFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::field_ref(ref v)) => v,
            _ => <RefFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_field_ref(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_field_ref(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::field_ref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_ref(&mut self, v: RefFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::field_ref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_ref(&mut self) -> &mut RefFunc {
        if let ::std::option::Option::Some(lambda::Inner::field_ref(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::field_ref(RefFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::field_ref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_ref(&mut self) -> RefFunc {
        if self.has_field_ref() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::field_ref(v)) => v,
                _ => panic!(),
            }
        } else {
            RefFunc::new()
        }
    }

    // optional .model.ConcatenateFunc concatenate = 8;

    pub fn get_concatenate(&self) -> &ConcatenateFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::concatenate(ref v)) => v,
            _ => <ConcatenateFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_concatenate(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_concatenate(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::concatenate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_concatenate(&mut self, v: ConcatenateFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::concatenate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_concatenate(&mut self) -> &mut ConcatenateFunc {
        if let ::std::option::Option::Some(lambda::Inner::concatenate(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::concatenate(ConcatenateFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::concatenate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_concatenate(&mut self) -> ConcatenateFunc {
        if self.has_concatenate() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::concatenate(v)) => v,
                _ => panic!(),
            }
        } else {
            ConcatenateFunc::new()
        }
    }

    // optional .model.PushStackFunc push_stack = 9;

    pub fn get_push_stack(&self) -> &PushStackFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::push_stack(ref v)) => v,
            _ => <PushStackFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_push_stack(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_push_stack(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::push_stack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_push_stack(&mut self, v: PushStackFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::push_stack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_push_stack(&mut self) -> &mut PushStackFunc {
        if let ::std::option::Option::Some(lambda::Inner::push_stack(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::push_stack(PushStackFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::push_stack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_push_stack(&mut self) -> PushStackFunc {
        if self.has_push_stack() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::push_stack(v)) => v,
                _ => panic!(),
            }
        } else {
            PushStackFunc::new()
        }
    }

    // optional string string = 10;

    pub fn get_string(&self) -> &str {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::string(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.inner = ::std::option::Option::Some(lambda::Inner::string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(lambda::Inner::string(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::string(::std::string::String::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .model.PipeArgsFunc pipe_args = 11;

    pub fn get_pipe_args(&self) -> &PipeArgsFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::pipe_args(ref v)) => v,
            _ => <PipeArgsFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pipe_args(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_pipe_args(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::pipe_args(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pipe_args(&mut self, v: PipeArgsFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::pipe_args(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pipe_args(&mut self) -> &mut PipeArgsFunc {
        if let ::std::option::Option::Some(lambda::Inner::pipe_args(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::pipe_args(PipeArgsFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::pipe_args(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pipe_args(&mut self) -> PipeArgsFunc {
        if self.has_pipe_args() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::pipe_args(v)) => v,
                _ => panic!(),
            }
        } else {
            PipeArgsFunc::new()
        }
    }

    // optional .model.PrependStackFunc prepend_stack = 12;

    pub fn get_prepend_stack(&self) -> &PrependStackFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::prepend_stack(ref v)) => v,
            _ => <PrependStackFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_prepend_stack(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_prepend_stack(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::prepend_stack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prepend_stack(&mut self, v: PrependStackFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::prepend_stack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prepend_stack(&mut self) -> &mut PrependStackFunc {
        if let ::std::option::Option::Some(lambda::Inner::prepend_stack(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::prepend_stack(PrependStackFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::prepend_stack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prepend_stack(&mut self) -> PrependStackFunc {
        if self.has_prepend_stack() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::prepend_stack(v)) => v,
                _ => panic!(),
            }
        } else {
            PrependStackFunc::new()
        }
    }

    // optional .model.SwitchFunc switch = 13;

    pub fn get_switch(&self) -> &SwitchFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::switch(ref v)) => v,
            _ => <SwitchFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_switch(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_switch(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::switch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch(&mut self, v: SwitchFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::switch(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch(&mut self) -> &mut SwitchFunc {
        if let ::std::option::Option::Some(lambda::Inner::switch(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::switch(SwitchFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::switch(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch(&mut self) -> SwitchFunc {
        if self.has_switch() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::switch(v)) => v,
                _ => panic!(),
            }
        } else {
            SwitchFunc::new()
        }
    }

    // optional .model.IsEqualFunc is_equal = 14;

    pub fn get_is_equal(&self) -> &IsEqualFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::is_equal(ref v)) => v,
            _ => <IsEqualFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_is_equal(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_is_equal(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::is_equal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_is_equal(&mut self, v: IsEqualFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::is_equal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_is_equal(&mut self) -> &mut IsEqualFunc {
        if let ::std::option::Option::Some(lambda::Inner::is_equal(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::is_equal(IsEqualFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::is_equal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_is_equal(&mut self) -> IsEqualFunc {
        if self.has_is_equal() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::is_equal(v)) => v,
                _ => panic!(),
            }
        } else {
            IsEqualFunc::new()
        }
    }

    // optional .model.GetPropFunc get_prop = 15;

    pub fn get_get_prop(&self) -> &GetPropFunc {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::get_prop(ref v)) => v,
            _ => <GetPropFunc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_prop(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_get_prop(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::get_prop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_prop(&mut self, v: GetPropFunc) {
        self.inner = ::std::option::Option::Some(lambda::Inner::get_prop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_prop(&mut self) -> &mut GetPropFunc {
        if let ::std::option::Option::Some(lambda::Inner::get_prop(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(lambda::Inner::get_prop(GetPropFunc::new()));
        }
        match self.inner {
            ::std::option::Option::Some(lambda::Inner::get_prop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_prop(&mut self) -> GetPropFunc {
        if self.has_get_prop() {
            match self.inner.take() {
                ::std::option::Option::Some(lambda::Inner::get_prop(v)) => v,
                _ => panic!(),
            }
        } else {
            GetPropFunc::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &Lambda| { &m.id },
            |m: &mut Lambda| { &mut m.id },
            Lambda::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &Lambda| { &m.args },
            |m: &mut Lambda| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HttpFunc>(
            "http",
            Lambda::has_http,
            Lambda::get_http,
            Lambda::mut_http,
            Lambda::set_http,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TCPFunc>(
            "tcp",
            Lambda::has_tcp,
            Lambda::get_tcp,
            Lambda::mut_tcp,
            Lambda::set_tcp,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MacroFunc>(
            "macro",
            Lambda::has_field_macro,
            Lambda::get_field_macro,
            Lambda::mut_field_macro,
            Lambda::set_field_macro,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DelayFunc>(
            "delay",
            Lambda::has_delay,
            Lambda::get_delay,
            Lambda::mut_delay,
            Lambda::set_delay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RefFunc>(
            "ref",
            Lambda::has_field_ref,
            Lambda::get_field_ref,
            Lambda::mut_field_ref,
            Lambda::set_field_ref,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ConcatenateFunc>(
            "concatenate",
            Lambda::has_concatenate,
            Lambda::get_concatenate,
            Lambda::mut_concatenate,
            Lambda::set_concatenate,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PushStackFunc>(
            "push_stack",
            Lambda::has_push_stack,
            Lambda::get_push_stack,
            Lambda::mut_push_stack,
            Lambda::set_push_stack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string",
            Lambda::has_string,
            Lambda::get_string,
            Lambda::set_string,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PipeArgsFunc>(
            "pipe_args",
            Lambda::has_pipe_args,
            Lambda::get_pipe_args,
            Lambda::mut_pipe_args,
            Lambda::set_pipe_args,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PrependStackFunc>(
            "prepend_stack",
            Lambda::has_prepend_stack,
            Lambda::get_prepend_stack,
            Lambda::mut_prepend_stack,
            Lambda::set_prepend_stack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwitchFunc>(
            "switch",
            Lambda::has_switch,
            Lambda::get_switch,
            Lambda::mut_switch,
            Lambda::set_switch,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, IsEqualFunc>(
            "is_equal",
            Lambda::has_is_equal,
            Lambda::get_is_equal,
            Lambda::mut_is_equal,
            Lambda::set_is_equal,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetPropFunc>(
            "get_prop",
            Lambda::has_get_prop,
            Lambda::get_get_prop,
            Lambda::mut_get_prop,
            Lambda::set_get_prop,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Lambda>(
            "Lambda",
            14,
            fields,
        )
    }
}

impl ::protobuf::Message for Lambda {
    fn is_initialized(&self) -> bool {
        if let Some(lambda::Inner::http(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::tcp(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::field_macro(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::delay(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::field_ref(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::concatenate(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::push_stack(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::pipe_args(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::prepend_stack(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::switch(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::is_equal(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(lambda::Inner::get_prop(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::http(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::tcp(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::field_macro(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::delay(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::field_ref(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::concatenate(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::push_stack(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::string(is.read_string()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::pipe_args(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::prepend_stack(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::switch(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::is_equal(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(lambda::Inner::get_prop(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &lambda::Inner::http(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::tcp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::field_macro(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::delay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::field_ref(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::concatenate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::push_stack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::string(ref v) => {
                    my_size += ::protobuf::rt::string_size(10, &v);
                },
                &lambda::Inner::pipe_args(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::prepend_stack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::switch(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::is_equal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &lambda::Inner::get_prop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.args {
            os.write_string(2, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &lambda::Inner::http(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &lambda::Inner::tcp(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &lambda::Inner::field_macro(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &lambda::Inner::delay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &lambda::Inner::field_ref(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &lambda::Inner::concatenate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &lambda::Inner::push_stack(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &lambda::Inner::string(ref v) => {
                    os.write_string(10, v)?;
                },
                &lambda::Inner::pipe_args(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &lambda::Inner::prepend_stack(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &lambda::Inner::switch(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &lambda::Inner::is_equal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &lambda::Inner::get_prop(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Lambda {
        Lambda::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 14)
    }

    fn default_instance() -> &'static Lambda {
        static instance: Lambda = Lambda {
            id: ::std::option::Option::None,
            args: ::std::vec::Vec::new(),
            inner: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Lambda {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.args.clear();
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Lambda {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Lambda {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Lambda`
pub mod lambda {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Inner {
        http(super::HttpFunc),
        tcp(super::TCPFunc),
        field_macro(super::MacroFunc),
        delay(super::DelayFunc),
        field_ref(super::RefFunc),
        concatenate(super::ConcatenateFunc),
        push_stack(super::PushStackFunc),
        string(::std::string::String),
        pipe_args(super::PipeArgsFunc),
        prepend_stack(super::PrependStackFunc),
        switch(super::SwitchFunc),
        is_equal(super::IsEqualFunc),
        get_prop(super::GetPropFunc),
    }

    impl ::protobuf::Oneof for Inner {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HttpFunc {
    // message fields
    url: ::std::option::Option<::std::string::String>,
    method: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<HttpMethod>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpFunc {
    fn default() -> &'a HttpFunc {
        <HttpFunc as ::protobuf::Message>::default_instance()
    }
}

impl HttpFunc {
    pub fn new() -> HttpFunc {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .model.HttpMethod method = 3;

    pub fn get_method(&self) -> HttpMethod {
        match self.method {
            Some(e) => e.enum_value_or(HttpMethod::GET),
            None => HttpMethod::GET,
        }
    }

    pub fn clear_method(&mut self) {
        self.method = ::std::option::Option::None;
    }

    pub fn has_method(&self) -> bool {
        self.method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: HttpMethod) {
        self.method = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "url",
            |m: &HttpFunc| { &m.url },
            |m: &mut HttpFunc| { &mut m.url },
            HttpFunc::get_url,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, HttpMethod>(
            "method",
            |m: &HttpFunc| { &m.method },
            |m: &mut HttpFunc| { &mut m.method },
            HttpMethod::GET,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HttpFunc>(
            "HttpFunc",
            15,
            fields,
        )
    }
}

impl ::protobuf::Message for HttpFunc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.method {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.method {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> HttpFunc {
        HttpFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 15)
    }

    fn default_instance() -> &'static HttpFunc {
        static instance: HttpFunc = HttpFunc {
            url: ::std::option::Option::None,
            method: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for HttpFunc {
    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.method = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct TCPFunc {
    // message fields
    address: ::std::option::Option<::std::string::String>,
    command: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TCPFunc {
    fn default() -> &'a TCPFunc {
        <TCPFunc as ::protobuf::Message>::default_instance()
    }
}

impl TCPFunc {
    pub fn new() -> TCPFunc {
        ::std::default::Default::default()
    }

    // optional string address = 1;

    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string command = 2;

    pub fn get_command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "address",
            |m: &TCPFunc| { &m.address },
            |m: &mut TCPFunc| { &mut m.address },
            TCPFunc::get_address,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "command",
            |m: &TCPFunc| { &m.command },
            |m: &mut TCPFunc| { &mut m.command },
            TCPFunc::get_command,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TCPFunc>(
            "TCPFunc",
            16,
            fields,
        )
    }
}

impl ::protobuf::Message for TCPFunc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.address = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.command.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.command.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TCPFunc {
        TCPFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 16)
    }

    fn default_instance() -> &'static TCPFunc {
        static instance: TCPFunc = TCPFunc {
            address: ::std::option::Option::None,
            command: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TCPFunc {
    fn clear(&mut self) {
        self.address = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TCPFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TCPFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct MacroFunc {
    // message fields
    pub lambdas: ::std::vec::Vec<Lambda>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a MacroFunc {
    fn default() -> &'a MacroFunc {
        <MacroFunc as ::protobuf::Message>::default_instance()
    }
}

impl MacroFunc {
    pub fn new() -> MacroFunc {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lambdas",
            |m: &MacroFunc| { &m.lambdas },
            |m: &mut MacroFunc| { &mut m.lambdas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MacroFunc>(
            "MacroFunc",
            17,
            fields,
        )
    }
}

impl ::protobuf::Message for MacroFunc {
    fn is_initialized(&self) -> bool {
        for v in &self.lambdas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.lambdas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.lambdas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.lambdas {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> MacroFunc {
        MacroFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 17)
    }

    fn default_instance() -> &'static MacroFunc {
        static instance: MacroFunc = MacroFunc {
            lambdas: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for MacroFunc {
    fn clear(&mut self) {
        self.lambdas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MacroFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MacroFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PipeArgsFunc {
    // message fields
    pub lambdas: ::std::vec::Vec<Lambda>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PipeArgsFunc {
    fn default() -> &'a PipeArgsFunc {
        <PipeArgsFunc as ::protobuf::Message>::default_instance()
    }
}

impl PipeArgsFunc {
    pub fn new() -> PipeArgsFunc {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lambdas",
            |m: &PipeArgsFunc| { &m.lambdas },
            |m: &mut PipeArgsFunc| { &mut m.lambdas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PipeArgsFunc>(
            "PipeArgsFunc",
            18,
            fields,
        )
    }
}

impl ::protobuf::Message for PipeArgsFunc {
    fn is_initialized(&self) -> bool {
        for v in &self.lambdas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.lambdas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.lambdas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.lambdas {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PipeArgsFunc {
        PipeArgsFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 18)
    }

    fn default_instance() -> &'static PipeArgsFunc {
        static instance: PipeArgsFunc = PipeArgsFunc {
            lambdas: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PipeArgsFunc {
    fn clear(&mut self) {
        self.lambdas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PipeArgsFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PipeArgsFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct DelayFunc {
    // message fields
    time: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelayFunc {
    fn default() -> &'a DelayFunc {
        <DelayFunc as ::protobuf::Message>::default_instance()
    }
}

impl DelayFunc {
    pub fn new() -> DelayFunc {
        ::std::default::Default::default()
    }

    // optional int32 time = 1;

    pub fn get_time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "time",
            |m: &DelayFunc| { &m.time },
            |m: &mut DelayFunc| { &mut m.time },
            DelayFunc::get_time,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelayFunc>(
            "DelayFunc",
            19,
            fields,
        )
    }
}

impl ::protobuf::Message for DelayFunc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.time {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> DelayFunc {
        DelayFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 19)
    }

    fn default_instance() -> &'static DelayFunc {
        static instance: DelayFunc = DelayFunc {
            time: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for DelayFunc {
    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelayFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelayFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RefFunc {
    // message fields
    device: ::std::option::Option<::std::string::String>,
    lambda: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefFunc {
    fn default() -> &'a RefFunc {
        <RefFunc as ::protobuf::Message>::default_instance()
    }
}

impl RefFunc {
    pub fn new() -> RefFunc {
        ::std::default::Default::default()
    }

    // optional string device = 1;

    pub fn get_device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        if self.device.is_none() {
            self.device = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        self.device.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string lambda = 2;

    pub fn get_lambda(&self) -> &str {
        match self.lambda.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lambda(&mut self) {
        self.lambda = ::std::option::Option::None;
    }

    pub fn has_lambda(&self) -> bool {
        self.lambda.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lambda(&mut self, v: ::std::string::String) {
        self.lambda = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lambda(&mut self) -> &mut ::std::string::String {
        if self.lambda.is_none() {
            self.lambda = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lambda.as_mut().unwrap()
    }

    // Take field
    pub fn take_lambda(&mut self) -> ::std::string::String {
        self.lambda.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "device",
            |m: &RefFunc| { &m.device },
            |m: &mut RefFunc| { &mut m.device },
            RefFunc::get_device,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "lambda",
            |m: &RefFunc| { &m.lambda },
            |m: &mut RefFunc| { &mut m.lambda },
            RefFunc::get_lambda,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefFunc>(
            "RefFunc",
            20,
            fields,
        )
    }
}

impl ::protobuf::Message for RefFunc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.device = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lambda = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.lambda.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.device.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.lambda.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RefFunc {
        RefFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 20)
    }

    fn default_instance() -> &'static RefFunc {
        static instance: RefFunc = RefFunc {
            device: ::std::option::Option::None,
            lambda: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RefFunc {
    fn clear(&mut self) {
        self.device = ::std::option::Option::None;
        self.lambda = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PushStackFunc {
    // message fields
    pub lambda: ::protobuf::MessageField<Lambda>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushStackFunc {
    fn default() -> &'a PushStackFunc {
        <PushStackFunc as ::protobuf::Message>::default_instance()
    }
}

impl PushStackFunc {
    pub fn new() -> PushStackFunc {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "lambda",
            |m: &PushStackFunc| { &m.lambda },
            |m: &mut PushStackFunc| { &mut m.lambda },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PushStackFunc>(
            "PushStackFunc",
            21,
            fields,
        )
    }
}

impl ::protobuf::Message for PushStackFunc {
    fn is_initialized(&self) -> bool {
        for v in &self.lambda {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.lambda)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lambda.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lambda.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PushStackFunc {
        PushStackFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 21)
    }

    fn default_instance() -> &'static PushStackFunc {
        static instance: PushStackFunc = PushStackFunc {
            lambda: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PushStackFunc {
    fn clear(&mut self) {
        self.lambda.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushStackFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushStackFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PrependStackFunc {
    // message fields
    pub lambda: ::protobuf::MessageField<Lambda>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrependStackFunc {
    fn default() -> &'a PrependStackFunc {
        <PrependStackFunc as ::protobuf::Message>::default_instance()
    }
}

impl PrependStackFunc {
    pub fn new() -> PrependStackFunc {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "lambda",
            |m: &PrependStackFunc| { &m.lambda },
            |m: &mut PrependStackFunc| { &mut m.lambda },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrependStackFunc>(
            "PrependStackFunc",
            22,
            fields,
        )
    }
}

impl ::protobuf::Message for PrependStackFunc {
    fn is_initialized(&self) -> bool {
        for v in &self.lambda {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.lambda)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lambda.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lambda.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PrependStackFunc {
        PrependStackFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 22)
    }

    fn default_instance() -> &'static PrependStackFunc {
        static instance: PrependStackFunc = PrependStackFunc {
            lambda: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PrependStackFunc {
    fn clear(&mut self) {
        self.lambda.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrependStackFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrependStackFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatenateFunc {
    // message fields
    pub strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConcatenateFunc {
    fn default() -> &'a ConcatenateFunc {
        <ConcatenateFunc as ::protobuf::Message>::default_instance()
    }
}

impl ConcatenateFunc {
    pub fn new() -> ConcatenateFunc {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &ConcatenateFunc| { &m.strings },
            |m: &mut ConcatenateFunc| { &mut m.strings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConcatenateFunc>(
            "ConcatenateFunc",
            23,
            fields,
        )
    }
}

impl ::protobuf::Message for ConcatenateFunc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.strings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ConcatenateFunc {
        ConcatenateFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 23)
    }

    fn default_instance() -> &'static ConcatenateFunc {
        static instance: ConcatenateFunc = ConcatenateFunc {
            strings: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ConcatenateFunc {
    fn clear(&mut self) {
        self.strings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatenateFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatenateFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Conditional {
    // message fields
    pub field_if: ::protobuf::MessageField<Lambda>,
    pub then: ::protobuf::MessageField<Lambda>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Conditional {
    fn default() -> &'a Conditional {
        <Conditional as ::protobuf::Message>::default_instance()
    }
}

impl Conditional {
    pub fn new() -> Conditional {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "if",
            |m: &Conditional| { &m.field_if },
            |m: &mut Conditional| { &mut m.field_if },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "then",
            |m: &Conditional| { &m.then },
            |m: &mut Conditional| { &mut m.then },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Conditional>(
            "Conditional",
            24,
            fields,
        )
    }
}

impl ::protobuf::Message for Conditional {
    fn is_initialized(&self) -> bool {
        if self.field_if.is_none() {
            return false;
        }
        if self.then.is_none() {
            return false;
        }
        for v in &self.field_if {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.field_if)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.then)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_if.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_if.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Conditional {
        Conditional::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 24)
    }

    fn default_instance() -> &'static Conditional {
        static instance: Conditional = Conditional {
            field_if: ::protobuf::MessageField::none(),
            then: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Conditional {
    fn clear(&mut self) {
        self.field_if.clear();
        self.then.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Conditional {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Conditional {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct SwitchFunc {
    // message fields
    pub conditions: ::std::vec::Vec<Conditional>,
    pub field_else: ::protobuf::MessageField<Lambda>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchFunc {
    fn default() -> &'a SwitchFunc {
        <SwitchFunc as ::protobuf::Message>::default_instance()
    }
}

impl SwitchFunc {
    pub fn new() -> SwitchFunc {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &SwitchFunc| { &m.conditions },
            |m: &mut SwitchFunc| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lambda>(
            "else",
            |m: &SwitchFunc| { &m.field_else },
            |m: &mut SwitchFunc| { &mut m.field_else },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchFunc>(
            "SwitchFunc",
            25,
            fields,
        )
    }
}

impl ::protobuf::Message for SwitchFunc {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_else {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.conditions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.field_else)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.field_else.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.field_else.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SwitchFunc {
        SwitchFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 25)
    }

    fn default_instance() -> &'static SwitchFunc {
        static instance: SwitchFunc = SwitchFunc {
            conditions: ::std::vec::Vec::new(),
            field_else: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SwitchFunc {
    fn clear(&mut self) {
        self.conditions.clear();
        self.field_else.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct IsEqualFunc {
    // message oneof groups
    pub from: ::std::option::Option<is_equal_func::From>,
    pub to: ::std::option::Option<is_equal_func::To>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsEqualFunc {
    fn default() -> &'a IsEqualFunc {
        <IsEqualFunc as ::protobuf::Message>::default_instance()
    }
}

impl IsEqualFunc {
    pub fn new() -> IsEqualFunc {
        ::std::default::Default::default()
    }

    // optional string from_string = 1;

    pub fn get_from_string(&self) -> &str {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_string(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_from_string(&mut self) {
        self.from = ::std::option::Option::None;
    }

    pub fn has_from_string(&self) -> bool {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_string(&mut self, v: ::std::string::String) {
        self.from = ::std::option::Option::Some(is_equal_func::From::from_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_from_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(is_equal_func::From::from_string(_)) = self.from {
        } else {
            self.from = ::std::option::Option::Some(is_equal_func::From::from_string(::std::string::String::new()));
        }
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_from_string(&mut self) -> ::std::string::String {
        if self.has_from_string() {
            match self.from.take() {
                ::std::option::Option::Some(is_equal_func::From::from_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional int64 from_int64 = 2;

    pub fn get_from_int64(&self) -> i64 {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_int64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_from_int64(&mut self) {
        self.from = ::std::option::Option::None;
    }

    pub fn has_from_int64(&self) -> bool {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_int64(&mut self, v: i64) {
        self.from = ::std::option::Option::Some(is_equal_func::From::from_int64(v))
    }

    // optional int32 from_int32 = 3;

    pub fn get_from_int32(&self) -> i32 {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_int32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_from_int32(&mut self) {
        self.from = ::std::option::Option::None;
    }

    pub fn has_from_int32(&self) -> bool {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_int32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_int32(&mut self, v: i32) {
        self.from = ::std::option::Option::Some(is_equal_func::From::from_int32(v))
    }

    // optional float from_float = 4;

    pub fn get_from_float(&self) -> f32 {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_float(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_from_float(&mut self) {
        self.from = ::std::option::Option::None;
    }

    pub fn has_from_float(&self) -> bool {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_float(&mut self, v: f32) {
        self.from = ::std::option::Option::Some(is_equal_func::From::from_float(v))
    }

    // optional bool from_bool = 5;

    pub fn get_from_bool(&self) -> bool {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_bool(v)) => v,
            _ => false,
        }
    }

    pub fn clear_from_bool(&mut self) {
        self.from = ::std::option::Option::None;
    }

    pub fn has_from_bool(&self) -> bool {
        match self.from {
            ::std::option::Option::Some(is_equal_func::From::from_bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_bool(&mut self, v: bool) {
        self.from = ::std::option::Option::Some(is_equal_func::From::from_bool(v))
    }

    // optional string to_string = 6;

    pub fn get_to_string(&self) -> &str {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_string(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_to_string(&mut self) {
        self.to = ::std::option::Option::None;
    }

    pub fn has_to_string(&self) -> bool {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_to_string(&mut self, v: ::std::string::String) {
        self.to = ::std::option::Option::Some(is_equal_func::To::to_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_to_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(is_equal_func::To::to_string(_)) = self.to {
        } else {
            self.to = ::std::option::Option::Some(is_equal_func::To::to_string(::std::string::String::new()));
        }
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_to_string(&mut self) -> ::std::string::String {
        if self.has_to_string() {
            match self.to.take() {
                ::std::option::Option::Some(is_equal_func::To::to_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional int64 to_int64 = 7;

    pub fn get_to_int64(&self) -> i64 {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_int64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_to_int64(&mut self) {
        self.to = ::std::option::Option::None;
    }

    pub fn has_to_int64(&self) -> bool {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_to_int64(&mut self, v: i64) {
        self.to = ::std::option::Option::Some(is_equal_func::To::to_int64(v))
    }

    // optional int32 to_int32 = 8;

    pub fn get_to_int32(&self) -> i32 {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_int32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_to_int32(&mut self) {
        self.to = ::std::option::Option::None;
    }

    pub fn has_to_int32(&self) -> bool {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_int32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_to_int32(&mut self, v: i32) {
        self.to = ::std::option::Option::Some(is_equal_func::To::to_int32(v))
    }

    // optional float to_float = 9;

    pub fn get_to_float(&self) -> f32 {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_float(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_to_float(&mut self) {
        self.to = ::std::option::Option::None;
    }

    pub fn has_to_float(&self) -> bool {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_to_float(&mut self, v: f32) {
        self.to = ::std::option::Option::Some(is_equal_func::To::to_float(v))
    }

    // optional bool to_bool = 10;

    pub fn get_to_bool(&self) -> bool {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_bool(v)) => v,
            _ => false,
        }
    }

    pub fn clear_to_bool(&mut self) {
        self.to = ::std::option::Option::None;
    }

    pub fn has_to_bool(&self) -> bool {
        match self.to {
            ::std::option::Option::Some(is_equal_func::To::to_bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_to_bool(&mut self, v: bool) {
        self.to = ::std::option::Option::Some(is_equal_func::To::to_bool(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "from_string",
            IsEqualFunc::has_from_string,
            IsEqualFunc::get_from_string,
            IsEqualFunc::set_from_string,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "from_int64",
            IsEqualFunc::has_from_int64,
            IsEqualFunc::get_from_int64,
            IsEqualFunc::set_from_int64,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "from_int32",
            IsEqualFunc::has_from_int32,
            IsEqualFunc::get_from_int32,
            IsEqualFunc::set_from_int32,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "from_float",
            IsEqualFunc::has_from_float,
            IsEqualFunc::get_from_float,
            IsEqualFunc::set_from_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "from_bool",
            IsEqualFunc::has_from_bool,
            IsEqualFunc::get_from_bool,
            IsEqualFunc::set_from_bool,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "to_string",
            IsEqualFunc::has_to_string,
            IsEqualFunc::get_to_string,
            IsEqualFunc::set_to_string,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "to_int64",
            IsEqualFunc::has_to_int64,
            IsEqualFunc::get_to_int64,
            IsEqualFunc::set_to_int64,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "to_int32",
            IsEqualFunc::has_to_int32,
            IsEqualFunc::get_to_int32,
            IsEqualFunc::set_to_int32,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "to_float",
            IsEqualFunc::has_to_float,
            IsEqualFunc::get_to_float,
            IsEqualFunc::set_to_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "to_bool",
            IsEqualFunc::has_to_bool,
            IsEqualFunc::get_to_bool,
            IsEqualFunc::set_to_bool,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IsEqualFunc>(
            "IsEqualFunc",
            26,
            fields,
        )
    }
}

impl ::protobuf::Message for IsEqualFunc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from = ::std::option::Option::Some(is_equal_func::From::from_string(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from = ::std::option::Option::Some(is_equal_func::From::from_int64(is.read_int64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from = ::std::option::Option::Some(is_equal_func::From::from_int32(is.read_int32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from = ::std::option::Option::Some(is_equal_func::From::from_float(is.read_float()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from = ::std::option::Option::Some(is_equal_func::From::from_bool(is.read_bool()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.to = ::std::option::Option::Some(is_equal_func::To::to_string(is.read_string()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.to = ::std::option::Option::Some(is_equal_func::To::to_int64(is.read_int64()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.to = ::std::option::Option::Some(is_equal_func::To::to_int32(is.read_int32()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.to = ::std::option::Option::Some(is_equal_func::To::to_float(is.read_float()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.to = ::std::option::Option::Some(is_equal_func::To::to_bool(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.from {
            match v {
                &is_equal_func::From::from_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &is_equal_func::From::from_int64(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &is_equal_func::From::from_int32(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &is_equal_func::From::from_float(v) => {
                    my_size += 5;
                },
                &is_equal_func::From::from_bool(v) => {
                    my_size += 2;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.to {
            match v {
                &is_equal_func::To::to_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
                &is_equal_func::To::to_int64(v) => {
                    my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &is_equal_func::To::to_int32(v) => {
                    my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &is_equal_func::To::to_float(v) => {
                    my_size += 5;
                },
                &is_equal_func::To::to_bool(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.from {
            match v {
                &is_equal_func::From::from_string(ref v) => {
                    os.write_string(1, v)?;
                },
                &is_equal_func::From::from_int64(v) => {
                    os.write_int64(2, v)?;
                },
                &is_equal_func::From::from_int32(v) => {
                    os.write_int32(3, v)?;
                },
                &is_equal_func::From::from_float(v) => {
                    os.write_float(4, v)?;
                },
                &is_equal_func::From::from_bool(v) => {
                    os.write_bool(5, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.to {
            match v {
                &is_equal_func::To::to_string(ref v) => {
                    os.write_string(6, v)?;
                },
                &is_equal_func::To::to_int64(v) => {
                    os.write_int64(7, v)?;
                },
                &is_equal_func::To::to_int32(v) => {
                    os.write_int32(8, v)?;
                },
                &is_equal_func::To::to_float(v) => {
                    os.write_float(9, v)?;
                },
                &is_equal_func::To::to_bool(v) => {
                    os.write_bool(10, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> IsEqualFunc {
        IsEqualFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 26)
    }

    fn default_instance() -> &'static IsEqualFunc {
        static instance: IsEqualFunc = IsEqualFunc {
            from: ::std::option::Option::None,
            to: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for IsEqualFunc {
    fn clear(&mut self) {
        self.from = ::std::option::Option::None;
        self.from = ::std::option::Option::None;
        self.from = ::std::option::Option::None;
        self.from = ::std::option::Option::None;
        self.from = ::std::option::Option::None;
        self.to = ::std::option::Option::None;
        self.to = ::std::option::Option::None;
        self.to = ::std::option::Option::None;
        self.to = ::std::option::Option::None;
        self.to = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsEqualFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsEqualFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `IsEqualFunc`
pub mod is_equal_func {

    #[derive(Clone,PartialEq,Debug)]
    pub enum From {
        from_string(::std::string::String),
        from_int64(i64),
        from_int32(i32),
        from_float(f32),
        from_bool(bool),
    }

    impl ::protobuf::Oneof for From {
    }

    #[derive(Clone,PartialEq,Debug)]
    pub enum To {
        to_string(::std::string::String),
        to_int64(i64),
        to_int32(i32),
        to_float(f32),
        to_bool(bool),
    }

    impl ::protobuf::Oneof for To {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPropFunc {
    // message fields
    prop: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPropFunc {
    fn default() -> &'a GetPropFunc {
        <GetPropFunc as ::protobuf::Message>::default_instance()
    }
}

impl GetPropFunc {
    pub fn new() -> GetPropFunc {
        ::std::default::Default::default()
    }

    // optional string prop = 1;

    pub fn get_prop(&self) -> &str {
        match self.prop.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_prop(&mut self) {
        self.prop = ::std::option::Option::None;
    }

    pub fn has_prop(&self) -> bool {
        self.prop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prop(&mut self, v: ::std::string::String) {
        self.prop = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prop(&mut self) -> &mut ::std::string::String {
        if self.prop.is_none() {
            self.prop = ::std::option::Option::Some(::std::string::String::new());
        }
        self.prop.as_mut().unwrap()
    }

    // Take field
    pub fn take_prop(&mut self) -> ::std::string::String {
        self.prop.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "prop",
            |m: &GetPropFunc| { &m.prop },
            |m: &mut GetPropFunc| { &mut m.prop },
            GetPropFunc::get_prop,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPropFunc>(
            "GetPropFunc",
            27,
            fields,
        )
    }
}

impl ::protobuf::Message for GetPropFunc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.prop = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prop.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prop.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetPropFunc {
        GetPropFunc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 27)
    }

    fn default_instance() -> &'static GetPropFunc {
        static instance: GetPropFunc = GetPropFunc {
            prop: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetPropFunc {
    fn clear(&mut self) {
        self.prop = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPropFunc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPropFunc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum Size {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
}

impl ::protobuf::ProtobufEnum for Size {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Size> {
        match value {
            0 => ::std::option::Option::Some(Size::SMALL),
            1 => ::std::option::Option::Some(Size::MEDIUM),
            2 => ::std::option::Option::Some(Size::LARGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Size] = &[
            Size::SMALL,
            Size::MEDIUM,
            Size::LARGE,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 0)
    }
}

impl ::std::default::Default for Size {
    fn default() -> Self {
        Size::SMALL
    }
}

impl ::protobuf::reflect::ProtobufValue for Size {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl Size {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<Size>("Size", 0)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum HttpMethod {
    GET = 0,
    HEAD = 1,
    POST = 2,
    PUT = 3,
    PATCH = 4,
    DELETE = 5,
}

impl ::protobuf::ProtobufEnum for HttpMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HttpMethod> {
        match value {
            0 => ::std::option::Option::Some(HttpMethod::GET),
            1 => ::std::option::Option::Some(HttpMethod::HEAD),
            2 => ::std::option::Option::Some(HttpMethod::POST),
            3 => ::std::option::Option::Some(HttpMethod::PUT),
            4 => ::std::option::Option::Some(HttpMethod::PATCH),
            5 => ::std::option::Option::Some(HttpMethod::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HttpMethod] = &[
            HttpMethod::GET,
            HttpMethod::HEAD,
            HttpMethod::POST,
            HttpMethod::PUT,
            HttpMethod::PATCH,
            HttpMethod::DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 1)
    }
}

impl ::std::default::Default for HttpMethod {
    fn default() -> Self {
        HttpMethod::GET
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpMethod {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl HttpMethod {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<HttpMethod>("HttpMethod", 1)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum Icon {
    STAR = 0,
    ARROW_UP = 1,
    ARROW_DOWN = 2,
    ARROW_LEFT = 3,
    ARROW_RIGHT = 4,
    SELECT = 5,
    VOLUME_UP = 6,
    VOLUME_DOWN = 7,
    VOLUME_MUTE = 8,
    BACK = 9,
    ON = 10,
    OFF = 11,
    FORWARD = 12,
    REVERSE = 13,
    INFO = 14,
    HOME = 15,
    CHANNEL_UP = 16,
    CHANNEL_DOWN = 17,
    CHANNEL = 18,
    REMOVE = 19,
    STOP = 20,
    SKIP_FORWARD = 21,
    SKIP_REVERSE = 22,
    RECORD = 23,
    PAUSE = 24,
    PLAY = 25,
    GUIDE = 26,
    DVR = 27,
    MENU = 28,
    OPTIONS = 29,
    EXIT = 30,
    ASTERISK = 31,
    POUND = 32,
    CLOSED_CAPTIONS = 33,
    GARAGE = 34,
    LAUNDRY = 35,
    KITCHEN = 36,
    NOOK = 37,
    FAMILY_ROOM = 38,
    LIVING_ROOM = 39,
    MEDIA_ROOM = 40,
    DINING_ROOM = 41,
    ENTRY = 42,
    MASTER_BEDROOM = 43,
    EXERCISE_ROOM = 44,
    PLAY_ROOM = 45,
    BEDROOM = 46,
    ROOM = 47,
    MENU_ALT = 48,
    PLUS = 49,
    MINUS = 50,
}

impl ::protobuf::ProtobufEnum for Icon {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Icon> {
        match value {
            0 => ::std::option::Option::Some(Icon::STAR),
            1 => ::std::option::Option::Some(Icon::ARROW_UP),
            2 => ::std::option::Option::Some(Icon::ARROW_DOWN),
            3 => ::std::option::Option::Some(Icon::ARROW_LEFT),
            4 => ::std::option::Option::Some(Icon::ARROW_RIGHT),
            5 => ::std::option::Option::Some(Icon::SELECT),
            6 => ::std::option::Option::Some(Icon::VOLUME_UP),
            7 => ::std::option::Option::Some(Icon::VOLUME_DOWN),
            8 => ::std::option::Option::Some(Icon::VOLUME_MUTE),
            9 => ::std::option::Option::Some(Icon::BACK),
            10 => ::std::option::Option::Some(Icon::ON),
            11 => ::std::option::Option::Some(Icon::OFF),
            12 => ::std::option::Option::Some(Icon::FORWARD),
            13 => ::std::option::Option::Some(Icon::REVERSE),
            14 => ::std::option::Option::Some(Icon::INFO),
            15 => ::std::option::Option::Some(Icon::HOME),
            16 => ::std::option::Option::Some(Icon::CHANNEL_UP),
            17 => ::std::option::Option::Some(Icon::CHANNEL_DOWN),
            18 => ::std::option::Option::Some(Icon::CHANNEL),
            19 => ::std::option::Option::Some(Icon::REMOVE),
            20 => ::std::option::Option::Some(Icon::STOP),
            21 => ::std::option::Option::Some(Icon::SKIP_FORWARD),
            22 => ::std::option::Option::Some(Icon::SKIP_REVERSE),
            23 => ::std::option::Option::Some(Icon::RECORD),
            24 => ::std::option::Option::Some(Icon::PAUSE),
            25 => ::std::option::Option::Some(Icon::PLAY),
            26 => ::std::option::Option::Some(Icon::GUIDE),
            27 => ::std::option::Option::Some(Icon::DVR),
            28 => ::std::option::Option::Some(Icon::MENU),
            29 => ::std::option::Option::Some(Icon::OPTIONS),
            30 => ::std::option::Option::Some(Icon::EXIT),
            31 => ::std::option::Option::Some(Icon::ASTERISK),
            32 => ::std::option::Option::Some(Icon::POUND),
            33 => ::std::option::Option::Some(Icon::CLOSED_CAPTIONS),
            34 => ::std::option::Option::Some(Icon::GARAGE),
            35 => ::std::option::Option::Some(Icon::LAUNDRY),
            36 => ::std::option::Option::Some(Icon::KITCHEN),
            37 => ::std::option::Option::Some(Icon::NOOK),
            38 => ::std::option::Option::Some(Icon::FAMILY_ROOM),
            39 => ::std::option::Option::Some(Icon::LIVING_ROOM),
            40 => ::std::option::Option::Some(Icon::MEDIA_ROOM),
            41 => ::std::option::Option::Some(Icon::DINING_ROOM),
            42 => ::std::option::Option::Some(Icon::ENTRY),
            43 => ::std::option::Option::Some(Icon::MASTER_BEDROOM),
            44 => ::std::option::Option::Some(Icon::EXERCISE_ROOM),
            45 => ::std::option::Option::Some(Icon::PLAY_ROOM),
            46 => ::std::option::Option::Some(Icon::BEDROOM),
            47 => ::std::option::Option::Some(Icon::ROOM),
            48 => ::std::option::Option::Some(Icon::MENU_ALT),
            49 => ::std::option::Option::Some(Icon::PLUS),
            50 => ::std::option::Option::Some(Icon::MINUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Icon] = &[
            Icon::STAR,
            Icon::ARROW_UP,
            Icon::ARROW_DOWN,
            Icon::ARROW_LEFT,
            Icon::ARROW_RIGHT,
            Icon::SELECT,
            Icon::VOLUME_UP,
            Icon::VOLUME_DOWN,
            Icon::VOLUME_MUTE,
            Icon::BACK,
            Icon::ON,
            Icon::OFF,
            Icon::FORWARD,
            Icon::REVERSE,
            Icon::INFO,
            Icon::HOME,
            Icon::CHANNEL_UP,
            Icon::CHANNEL_DOWN,
            Icon::CHANNEL,
            Icon::REMOVE,
            Icon::STOP,
            Icon::SKIP_FORWARD,
            Icon::SKIP_REVERSE,
            Icon::RECORD,
            Icon::PAUSE,
            Icon::PLAY,
            Icon::GUIDE,
            Icon::DVR,
            Icon::MENU,
            Icon::OPTIONS,
            Icon::EXIT,
            Icon::ASTERISK,
            Icon::POUND,
            Icon::CLOSED_CAPTIONS,
            Icon::GARAGE,
            Icon::LAUNDRY,
            Icon::KITCHEN,
            Icon::NOOK,
            Icon::FAMILY_ROOM,
            Icon::LIVING_ROOM,
            Icon::MEDIA_ROOM,
            Icon::DINING_ROOM,
            Icon::ENTRY,
            Icon::MASTER_BEDROOM,
            Icon::EXERCISE_ROOM,
            Icon::PLAY_ROOM,
            Icon::BEDROOM,
            Icon::ROOM,
            Icon::MENU_ALT,
            Icon::PLUS,
            Icon::MINUS,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 2)
    }
}

impl ::std::default::Default for Icon {
    fn default() -> Self {
        Icon::STAR
    }
}

impl ::protobuf::reflect::ProtobufValue for Icon {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl Icon {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<Icon>("Icon", 2)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17OpenControllerLib.proto\x12\x05model\"\x86\x01\n\x05House\x12!\n\
    \x0cdisplay_name\x18\x01\x20\x02(\tR\x0bdisplayName\x12\x0e\n\x02id\x18\
    \x02\x20\x02(\tR\x02id\x12!\n\x05rooms\x18\x03\x20\x03(\x0b2\x0b.model.R\
    oomR\x05rooms\x12'\n\x07devices\x18\x04\x20\x03(\x0b2\r.model.DeviceR\
    \x07devices\"\x95\x01\n\x04Room\x12!\n\x0cdisplay_name\x18\x01\x20\x02(\
    \tR\x0bdisplayName\x12\x0e\n\x02id\x18\x02\x20\x02(\tR\x02id\x123\n\x0bc\
    ontrollers\x18\x03\x20\x03(\x0b2\x11.model.ControllerR\x0bcontrollers\
    \x12%\n\x04icon\x18\x04\x20\x01(\x0e2\x0b.model.Icon:\x04ROOMR\x04icon\"\
    \x89\x01\n\nController\x12!\n\x0cdisplay_name\x18\x01\x20\x02(\tR\x0bdis\
    playName\x12\x0e\n\x02id\x18\x02\x20\x02(\tR\x02id\x12'\n\x07widgets\x18\
    \x03\x20\x03(\x0b2\r.model.WidgetR\x07widgets\x12\x1f\n\x0bbrand_color\
    \x18\x04\x20\x01(\tR\nbrandColor\"A\n\x06Device\x12\x0e\n\x02id\x18\x01\
    \x20\x02(\tR\x02id\x12'\n\x07lambdas\x18\x02\x20\x03(\x0b2\r.model.Lambd\
    aR\x07lambdas\"\x93\x03\n\x06Widget\x12\x16\n\x06expand\x18\x01\x20\x01(\
    \x08R\x06expand\x12'\n\x06button\x18\x02\x20\x01(\x0b2\r.model.ButtonH\0\
    R\x06button\x12\x1e\n\x03row\x18\x03\x20\x01(\x0b2\n.model.RowH\0R\x03ro\
    w\x12'\n\x06column\x18\x04\x20\x01(\x0b2\r.model.ColumnH\0R\x06column\
    \x127\n\x0carrow_layout\x18\x05\x20\x01(\x0b2\x12.model.ArrowLayoutH\0R\
    \x0barrowLayout\x12$\n\x05space\x18\x06\x20\x01(\x0b2\x0c.model.SpaceH\0\
    R\x05space\x121\n\ntext_input\x18\x07\x20\x01(\x0b2\x10.model.TextInputH\
    \0R\ttextInput\x12.\n\tswipe_pad\x18\x08\x20\x01(\x0b2\x0f.model.SwipePa\
    dH\0R\x08swipePad\x124\n\x0bmenu_button\x18\t\x20\x01(\x0b2\x11.model.Me\
    nuButtonH\0R\nmenuButtonB\x07\n\x05inner\"\x8f\x01\n\x06Button\x12(\n\
    \x08on_click\x18\x01\x20\x02(\x0b2\r.model.LambdaR\x07onClick\x12\x1f\n\
    \x04icon\x18\x02\x20\x01(\x0e2\x0b.model.IconR\x04icon\x12\x12\n\x04text\
    \x18\x03\x20\x02(\tR\x04text\x12&\n\x04size\x18\x04\x20\x01(\x0e2\x0b.mo\
    del.Size:\x05SMALLR\x04size\"0\n\x03Row\x12)\n\x08children\x18\x01\x20\
    \x03(\x0b2\r.model.WidgetR\x08children\"3\n\x06Column\x12)\n\x08children\
    \x18\x01\x20\x03(\x0b2\r.model.WidgetR\x08children\"\xc4\x01\n\x0bArrowL\
    ayout\x12\x1f\n\x03top\x18\x01\x20\x02(\x0b2\r.model.WidgetR\x03top\x12%\
    \n\x06bottom\x18\x02\x20\x02(\x0b2\r.model.WidgetR\x06bottom\x12!\n\x04l\
    eft\x18\x03\x20\x02(\x0b2\r.model.WidgetR\x04left\x12#\n\x05right\x18\
    \x04\x20\x02(\x0b2\r.model.WidgetR\x05right\x12%\n\x06center\x18\x05\x20\
    \x02(\x0b2\r.model.WidgetR\x06center\"\xad\x04\n\x08SwipePad\x12-\n\x0bo\
    n_swipe_up\x18\x01\x20\x02(\x0b2\r.model.LambdaR\tonSwipeUp\x121\n\ron_s\
    wipe_down\x18\x02\x20\x02(\x0b2\r.model.LambdaR\x0bonSwipeDown\x121\n\ro\
    n_swipe_left\x18\x03\x20\x02(\x0b2\r.model.LambdaR\x0bonSwipeLeft\x123\n\
    \x0eon_swipe_right\x18\x04\x20\x02(\x0b2\r.model.LambdaR\x0conSwipeRight\
    \x12(\n\x08on_click\x18\x05\x20\x02(\x0b2\r.model.LambdaR\x07onClick\x12\
    ;\n\x12on_bottom_increase\x18\x06\x20\x01(\x0b2\r.model.LambdaR\x10onBot\
    tomIncrease\x12;\n\x12on_bottom_decrease\x18\x07\x20\x01(\x0b2\r.model.L\
    ambdaR\x10onBottomDecrease\x125\n\x0fon_bottom_click\x18\x08\x20\x01(\
    \x0b2\r.model.LambdaR\ronBottomClick\x12=\n\x14bottom_increase_icon\x18\
    \t\x20\x01(\x0e2\x0b.model.IconR\x12bottomIncreaseIcon\x12=\n\x14bottom_\
    decrease_icon\x18\n\x20\x01(\x0e2\x0b.model.IconR\x12bottomDecreaseIcon\
    \"j\n\tTextInput\x12(\n\x08on_input\x18\x01\x20\x02(\x0b2\r.model.Lambda\
    R\x07onInput\x12\x12\n\x04text\x18\x03\x20\x02(\tR\x04text\x12\x1f\n\x04\
    icon\x18\x02\x20\x01(\x0e2\x0b.model.IconR\x04icon\"\x98\x01\n\x0fTextIn\
    putAction\x12\x14\n\x04char\x18\x01\x20\x01(\tH\0R\x04char\x12\x1e\n\tba\
    ckspace\x18\x02\x20\x01(\x08H\0R\tbackspace\x12!\n\x0bcursor_left\x18\
    \x03\x20\x01(\x08H\0R\ncursorLeft\x12#\n\x0ccursor_right\x18\x04\x20\x01\
    (\x08H\0R\x0bcursorRightB\x07\n\x05inner\"\x92\x01\n\nMenuButton\x12'\n\
    \x07content\x18\x01\x20\x03(\x0b2\r.model.WidgetR\x07content\x12\x12\n\
    \x04text\x18\x02\x20\x02(\tR\x04text\x12\x1f\n\x04icon\x18\x03\x20\x01(\
    \x0e2\x0b.model.IconR\x04icon\x12&\n\x04size\x18\x04\x20\x01(\x0e2\x0b.m\
    odel.Size:\x05SMALLR\x04size\"\x07\n\x05Space\"\x88\x05\n\x06Lambda\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04args\x18\x02\x20\x03\
    (\tR\x04args\x12%\n\x04http\x18\x03\x20\x01(\x0b2\x0f.model.HttpFuncH\0R\
    \x04http\x12\"\n\x03tcp\x18\x04\x20\x01(\x0b2\x0e.model.TCPFuncH\0R\x03t\
    cp\x12(\n\x05macro\x18\x05\x20\x01(\x0b2\x10.model.MacroFuncH\0R\x05macr\
    o\x12(\n\x05delay\x18\x06\x20\x01(\x0b2\x10.model.DelayFuncH\0R\x05delay\
    \x12\"\n\x03ref\x18\x07\x20\x01(\x0b2\x0e.model.RefFuncH\0R\x03ref\x12:\
    \n\x0bconcatenate\x18\x08\x20\x01(\x0b2\x16.model.ConcatenateFuncH\0R\
    \x0bconcatenate\x125\n\npush_stack\x18\t\x20\x01(\x0b2\x14.model.PushSta\
    ckFuncH\0R\tpushStack\x12\x18\n\x06string\x18\n\x20\x01(\tH\0R\x06string\
    \x122\n\tpipe_args\x18\x0b\x20\x01(\x0b2\x13.model.PipeArgsFuncH\0R\x08p\
    ipeArgs\x12>\n\rprepend_stack\x18\x0c\x20\x01(\x0b2\x17.model.PrependSta\
    ckFuncH\0R\x0cprependStack\x12+\n\x06switch\x18\r\x20\x01(\x0b2\x11.mode\
    l.SwitchFuncH\0R\x06switch\x12/\n\x08is_equal\x18\x0e\x20\x01(\x0b2\x12.\
    model.IsEqualFuncH\0R\x07isEqual\x12/\n\x08get_prop\x18\x0f\x20\x01(\x0b\
    2\x12.model.GetPropFuncH\0R\x07getPropB\x07\n\x05inner\"G\n\x08HttpFunc\
    \x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12)\n\x06method\x18\x03\
    \x20\x01(\x0e2\x11.model.HttpMethodR\x06method\"=\n\x07TCPFunc\x12\x18\n\
    \x07address\x18\x01\x20\x01(\tR\x07address\x12\x18\n\x07command\x18\x02\
    \x20\x01(\tR\x07command\"4\n\tMacroFunc\x12'\n\x07lambdas\x18\x01\x20\
    \x03(\x0b2\r.model.LambdaR\x07lambdas\"7\n\x0cPipeArgsFunc\x12'\n\x07lam\
    bdas\x18\x01\x20\x03(\x0b2\r.model.LambdaR\x07lambdas\"\x1f\n\tDelayFunc\
    \x12\x12\n\x04time\x18\x01\x20\x01(\x05R\x04time\"9\n\x07RefFunc\x12\x16\
    \n\x06device\x18\x01\x20\x01(\tR\x06device\x12\x16\n\x06lambda\x18\x02\
    \x20\x01(\tR\x06lambda\"6\n\rPushStackFunc\x12%\n\x06lambda\x18\x01\x20\
    \x01(\x0b2\r.model.LambdaR\x06lambda\"9\n\x10PrependStackFunc\x12%\n\x06\
    lambda\x18\x01\x20\x01(\x0b2\r.model.LambdaR\x06lambda\"+\n\x0fConcatena\
    teFunc\x12\x18\n\x07strings\x18\x01\x20\x03(\tR\x07strings\"O\n\x0bCondi\
    tional\x12\x1d\n\x02if\x18\x01\x20\x02(\x0b2\r.model.LambdaR\x02if\x12!\
    \n\x04then\x18\x02\x20\x02(\x0b2\r.model.LambdaR\x04then\"c\n\nSwitchFun\
    c\x122\n\nconditions\x18\x01\x20\x03(\x0b2\x12.model.ConditionalR\ncondi\
    tions\x12!\n\x04else\x18\x02\x20\x01(\x0b2\r.model.LambdaR\x04else\"\xd1\
    \x02\n\x0bIsEqualFunc\x12!\n\x0bfrom_string\x18\x01\x20\x01(\tH\0R\nfrom\
    String\x12\x1f\n\nfrom_int64\x18\x02\x20\x01(\x03H\0R\tfromInt64\x12\x1f\
    \n\nfrom_int32\x18\x03\x20\x01(\x05H\0R\tfromInt32\x12\x1f\n\nfrom_float\
    \x18\x04\x20\x01(\x02H\0R\tfromFloat\x12\x1d\n\tfrom_bool\x18\x05\x20\
    \x01(\x08H\0R\x08fromBool\x12\x1d\n\tto_string\x18\x06\x20\x01(\tH\x01R\
    \x08toString\x12\x1b\n\x08to_int64\x18\x07\x20\x01(\x03H\x01R\x07toInt64\
    \x12\x1b\n\x08to_int32\x18\x08\x20\x01(\x05H\x01R\x07toInt32\x12\x1b\n\
    \x08to_float\x18\t\x20\x01(\x02H\x01R\x07toFloat\x12\x19\n\x07to_bool\
    \x18\n\x20\x01(\x08H\x01R\x06toBoolB\x06\n\x04fromB\x04\n\x02to\"!\n\x0b\
    GetPropFunc\x12\x12\n\x04prop\x18\x01\x20\x01(\tR\x04prop*(\n\x04Size\
    \x12\t\n\x05SMALL\x10\0\x12\n\n\x06MEDIUM\x10\x01\x12\t\n\x05LARGE\x10\
    \x02*I\n\nHttpMethod\x12\x07\n\x03GET\x10\0\x12\x08\n\x04HEAD\x10\x01\
    \x12\x08\n\x04POST\x10\x02\x12\x07\n\x03PUT\x10\x03\x12\t\n\x05PATCH\x10\
    \x04\x12\n\n\x06DELETE\x10\x05*\xb0\x05\n\x04Icon\x12\x08\n\x04STAR\x10\
    \0\x12\x0c\n\x08ARROW_UP\x10\x01\x12\x0e\n\nARROW_DOWN\x10\x02\x12\x0e\n\
    \nARROW_LEFT\x10\x03\x12\x0f\n\x0bARROW_RIGHT\x10\x04\x12\n\n\x06SELECT\
    \x10\x05\x12\r\n\tVOLUME_UP\x10\x06\x12\x0f\n\x0bVOLUME_DOWN\x10\x07\x12\
    \x0f\n\x0bVOLUME_MUTE\x10\x08\x12\x08\n\x04BACK\x10\t\x12\x06\n\x02ON\
    \x10\n\x12\x07\n\x03OFF\x10\x0b\x12\x0b\n\x07FORWARD\x10\x0c\x12\x0b\n\
    \x07REVERSE\x10\r\x12\x08\n\x04INFO\x10\x0e\x12\x08\n\x04HOME\x10\x0f\
    \x12\x0e\n\nCHANNEL_UP\x10\x10\x12\x10\n\x0cCHANNEL_DOWN\x10\x11\x12\x0b\
    \n\x07CHANNEL\x10\x12\x12\n\n\x06REMOVE\x10\x13\x12\x08\n\x04STOP\x10\
    \x14\x12\x10\n\x0cSKIP_FORWARD\x10\x15\x12\x10\n\x0cSKIP_REVERSE\x10\x16\
    \x12\n\n\x06RECORD\x10\x17\x12\t\n\x05PAUSE\x10\x18\x12\x08\n\x04PLAY\
    \x10\x19\x12\t\n\x05GUIDE\x10\x1a\x12\x07\n\x03DVR\x10\x1b\x12\x08\n\x04\
    MENU\x10\x1c\x12\x0b\n\x07OPTIONS\x10\x1d\x12\x08\n\x04EXIT\x10\x1e\x12\
    \x0c\n\x08ASTERISK\x10\x1f\x12\t\n\x05POUND\x10\x20\x12\x13\n\x0fCLOSED_\
    CAPTIONS\x10!\x12\n\n\x06GARAGE\x10\"\x12\x0b\n\x07LAUNDRY\x10#\x12\x0b\
    \n\x07KITCHEN\x10$\x12\x08\n\x04NOOK\x10%\x12\x0f\n\x0bFAMILY_ROOM\x10&\
    \x12\x0f\n\x0bLIVING_ROOM\x10'\x12\x0e\n\nMEDIA_ROOM\x10(\x12\x0f\n\x0bD\
    INING_ROOM\x10)\x12\t\n\x05ENTRY\x10*\x12\x12\n\x0eMASTER_BEDROOM\x10+\
    \x12\x11\n\rEXERCISE_ROOM\x10,\x12\r\n\tPLAY_ROOM\x10-\x12\x0b\n\x07BEDR\
    OOM\x10.\x12\x08\n\x04ROOM\x10/\x12\x0c\n\x08MENU_ALT\x100\x12\x08\n\x04\
    PLUS\x101\x12\t\n\x05MINUS\x102BR\n&com.pjtsearch.opencontroller_lib_pro\
    toP\x01Z&pjtsearch.com/opencontroller_lib_proto\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(House::generated_message_descriptor_data());
        messages.push(Room::generated_message_descriptor_data());
        messages.push(Controller::generated_message_descriptor_data());
        messages.push(Device::generated_message_descriptor_data());
        messages.push(Widget::generated_message_descriptor_data());
        messages.push(Button::generated_message_descriptor_data());
        messages.push(Row::generated_message_descriptor_data());
        messages.push(Column::generated_message_descriptor_data());
        messages.push(ArrowLayout::generated_message_descriptor_data());
        messages.push(SwipePad::generated_message_descriptor_data());
        messages.push(TextInput::generated_message_descriptor_data());
        messages.push(TextInputAction::generated_message_descriptor_data());
        messages.push(MenuButton::generated_message_descriptor_data());
        messages.push(Space::generated_message_descriptor_data());
        messages.push(Lambda::generated_message_descriptor_data());
        messages.push(HttpFunc::generated_message_descriptor_data());
        messages.push(TCPFunc::generated_message_descriptor_data());
        messages.push(MacroFunc::generated_message_descriptor_data());
        messages.push(PipeArgsFunc::generated_message_descriptor_data());
        messages.push(DelayFunc::generated_message_descriptor_data());
        messages.push(RefFunc::generated_message_descriptor_data());
        messages.push(PushStackFunc::generated_message_descriptor_data());
        messages.push(PrependStackFunc::generated_message_descriptor_data());
        messages.push(ConcatenateFunc::generated_message_descriptor_data());
        messages.push(Conditional::generated_message_descriptor_data());
        messages.push(SwitchFunc::generated_message_descriptor_data());
        messages.push(IsEqualFunc::generated_message_descriptor_data());
        messages.push(GetPropFunc::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(Size::generated_enum_descriptor_data());
        enums.push(HttpMethod::generated_enum_descriptor_data());
        enums.push(Icon::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
