// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `OpenControllerLib.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct HouseExpr {
    // message fields
    pub display_name: ::protobuf::MessageField<Expr>,
    pub id: ::protobuf::MessageField<Expr>,
    pub rooms: ::std::collections::HashMap<::std::string::String, Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a HouseExpr {
    fn default() -> &'a HouseExpr {
        <HouseExpr as ::protobuf::Message>::default_instance()
    }
}

impl HouseExpr {
    pub fn new() -> HouseExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_name",
            |m: &HouseExpr| { &m.display_name },
            |m: &mut HouseExpr| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "id",
            |m: &HouseExpr| { &m.id },
            |m: &mut HouseExpr| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "rooms",
            |m: &HouseExpr| { &m.rooms },
            |m: &mut HouseExpr| { &mut m.rooms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HouseExpr>(
            "HouseExpr",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for HouseExpr {
    fn is_initialized(&self) -> bool {
        if self.display_name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(wire_type, is, &mut self.rooms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(3, &self.rooms);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(3, &self.rooms, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> HouseExpr {
        HouseExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static HouseExpr {
        static instance: ::protobuf::rt::LazyV2<HouseExpr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HouseExpr::new)
    }
}

impl ::protobuf::Clear for HouseExpr {
    fn clear(&mut self) {
        self.display_name.clear();
        self.id.clear();
        self.rooms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HouseExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HouseExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RoomExpr {
    // message fields
    pub display_name: ::protobuf::MessageField<Expr>,
    pub controllers: ::std::collections::HashMap<::std::string::String, Expr>,
    pub icon: ::protobuf::MessageField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoomExpr {
    fn default() -> &'a RoomExpr {
        <RoomExpr as ::protobuf::Message>::default_instance()
    }
}

impl RoomExpr {
    pub fn new() -> RoomExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_name",
            |m: &RoomExpr| { &m.display_name },
            |m: &mut RoomExpr| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "controllers",
            |m: &RoomExpr| { &m.controllers },
            |m: &mut RoomExpr| { &mut m.controllers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "icon",
            |m: &RoomExpr| { &m.icon },
            |m: &mut RoomExpr| { &mut m.icon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoomExpr>(
            "RoomExpr",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for RoomExpr {
    fn is_initialized(&self) -> bool {
        if self.display_name.is_none() {
            return false;
        }
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.icon {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(wire_type, is, &mut self.controllers)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.icon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(2, &self.controllers);
        if let Some(v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(2, &self.controllers, os)?;
        if let Some(v) = self.icon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RoomExpr {
        RoomExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static RoomExpr {
        static instance: ::protobuf::rt::LazyV2<RoomExpr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoomExpr::new)
    }
}

impl ::protobuf::Clear for RoomExpr {
    fn clear(&mut self) {
        self.display_name.clear();
        self.controllers.clear();
        self.icon.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoomExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct ControllerExpr {
    // message fields
    pub display_name: ::protobuf::MessageField<Expr>,
    pub brand_color: ::protobuf::MessageField<Expr>,
    pub display_interface: ::protobuf::MessageField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControllerExpr {
    fn default() -> &'a ControllerExpr {
        <ControllerExpr as ::protobuf::Message>::default_instance()
    }
}

impl ControllerExpr {
    pub fn new() -> ControllerExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_name",
            |m: &ControllerExpr| { &m.display_name },
            |m: &mut ControllerExpr| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "brand_color",
            |m: &ControllerExpr| { &m.brand_color },
            |m: &mut ControllerExpr| { &mut m.brand_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_interface",
            |m: &ControllerExpr| { &m.display_interface },
            |m: &mut ControllerExpr| { &mut m.display_interface },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerExpr>(
            "ControllerExpr",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for ControllerExpr {
    fn is_initialized(&self) -> bool {
        if self.display_name.is_none() {
            return false;
        }
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.brand_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display_interface {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.brand_color)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.display_interface)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.brand_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.display_interface.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.brand_color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.display_interface.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ControllerExpr {
        ControllerExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static ControllerExpr {
        static instance: ControllerExpr = ControllerExpr {
            display_name: ::protobuf::MessageField::none(),
            brand_color: ::protobuf::MessageField::none(),
            display_interface: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ControllerExpr {
    fn clear(&mut self) {
        self.display_name.clear();
        self.brand_color.clear();
        self.display_interface.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControllerExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct DisplayInterfaceExpr {
    // message fields
    pub widgets: ::std::vec::Vec<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisplayInterfaceExpr {
    fn default() -> &'a DisplayInterfaceExpr {
        <DisplayInterfaceExpr as ::protobuf::Message>::default_instance()
    }
}

impl DisplayInterfaceExpr {
    pub fn new() -> DisplayInterfaceExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "widgets",
            |m: &DisplayInterfaceExpr| { &m.widgets },
            |m: &mut DisplayInterfaceExpr| { &mut m.widgets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayInterfaceExpr>(
            "DisplayInterfaceExpr",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for DisplayInterfaceExpr {
    fn is_initialized(&self) -> bool {
        for v in &self.widgets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.widgets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.widgets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.widgets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> DisplayInterfaceExpr {
        DisplayInterfaceExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static DisplayInterfaceExpr {
        static instance: DisplayInterfaceExpr = DisplayInterfaceExpr {
            widgets: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for DisplayInterfaceExpr {
    fn clear(&mut self) {
        self.widgets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisplayInterfaceExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayInterfaceExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceExpr {
    // message fields
    pub lambdas: ::std::collections::HashMap<::std::string::String, Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceExpr {
    fn default() -> &'a DeviceExpr {
        <DeviceExpr as ::protobuf::Message>::default_instance()
    }
}

impl DeviceExpr {
    pub fn new() -> DeviceExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "lambdas",
            |m: &DeviceExpr| { &m.lambdas },
            |m: &mut DeviceExpr| { &mut m.lambdas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceExpr>(
            "DeviceExpr",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for DeviceExpr {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(wire_type, is, &mut self.lambdas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(1, &self.lambdas);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(1, &self.lambdas, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> DeviceExpr {
        DeviceExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static DeviceExpr {
        static instance: ::protobuf::rt::LazyV2<DeviceExpr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceExpr::new)
    }
}

impl ::protobuf::Clear for DeviceExpr {
    fn clear(&mut self) {
        self.lambdas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct WidgetExpr {
    // message fields
    widget_type: ::std::option::Option<::std::string::String>,
    pub params: ::std::collections::HashMap<::std::string::String, Expr>,
    pub children: ::std::vec::Vec<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a WidgetExpr {
    fn default() -> &'a WidgetExpr {
        <WidgetExpr as ::protobuf::Message>::default_instance()
    }
}

impl WidgetExpr {
    pub fn new() -> WidgetExpr {
        ::std::default::Default::default()
    }

    // required string widget_type = 2;

    pub fn get_widget_type(&self) -> &str {
        match self.widget_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_widget_type(&mut self) {
        self.widget_type = ::std::option::Option::None;
    }

    pub fn has_widget_type(&self) -> bool {
        self.widget_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_widget_type(&mut self, v: ::std::string::String) {
        self.widget_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_widget_type(&mut self) -> &mut ::std::string::String {
        if self.widget_type.is_none() {
            self.widget_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.widget_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_widget_type(&mut self) -> ::std::string::String {
        self.widget_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "widget_type",
            |m: &WidgetExpr| { &m.widget_type },
            |m: &mut WidgetExpr| { &mut m.widget_type },
            WidgetExpr::get_widget_type,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "params",
            |m: &WidgetExpr| { &m.params },
            |m: &mut WidgetExpr| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "children",
            |m: &WidgetExpr| { &m.children },
            |m: &mut WidgetExpr| { &mut m.children },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WidgetExpr>(
            "WidgetExpr",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for WidgetExpr {
    fn is_initialized(&self) -> bool {
        if self.widget_type.is_none() {
            return false;
        }
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.widget_type = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(wire_type, is, &mut self.params)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.children)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.widget_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(3, &self.params);
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.widget_type.as_ref() {
            os.write_string(2, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Expr>>(3, &self.params, os)?;
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> WidgetExpr {
        WidgetExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static WidgetExpr {
        static instance: ::protobuf::rt::LazyV2<WidgetExpr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WidgetExpr::new)
    }
}

impl ::protobuf::Clear for WidgetExpr {
    fn clear(&mut self) {
        self.widget_type = ::std::option::Option::None;
        self.params.clear();
        self.children.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WidgetExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WidgetExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RefExpr {
    // message fields
    field_ref: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefExpr {
    fn default() -> &'a RefExpr {
        <RefExpr as ::protobuf::Message>::default_instance()
    }
}

impl RefExpr {
    pub fn new() -> RefExpr {
        ::std::default::Default::default()
    }

    // required string ref = 1;

    pub fn get_field_ref(&self) -> &str {
        match self.field_ref.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_field_ref(&mut self) {
        self.field_ref = ::std::option::Option::None;
    }

    pub fn has_field_ref(&self) -> bool {
        self.field_ref.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_ref(&mut self, v: ::std::string::String) {
        self.field_ref = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_ref(&mut self) -> &mut ::std::string::String {
        if self.field_ref.is_none() {
            self.field_ref = ::std::option::Option::Some(::std::string::String::new());
        }
        self.field_ref.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_ref(&mut self) -> ::std::string::String {
        self.field_ref.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "ref",
            |m: &RefExpr| { &m.field_ref },
            |m: &mut RefExpr| { &mut m.field_ref },
            RefExpr::get_field_ref,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefExpr>(
            "RefExpr",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for RefExpr {
    fn is_initialized(&self) -> bool {
        if self.field_ref.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_ref = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_ref.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_ref.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RefExpr {
        RefExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static RefExpr {
        static instance: RefExpr = RefExpr {
            field_ref: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RefExpr {
    fn clear(&mut self) {
        self.field_ref = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct LambdaExpr {
    // message fields
    pub args: ::std::vec::Vec<::std::string::String>,
    pub field_return: ::protobuf::MessageField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a LambdaExpr {
    fn default() -> &'a LambdaExpr {
        <LambdaExpr as ::protobuf::Message>::default_instance()
    }
}

impl LambdaExpr {
    pub fn new() -> LambdaExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &LambdaExpr| { &m.args },
            |m: &mut LambdaExpr| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "return",
            |m: &LambdaExpr| { &m.field_return },
            |m: &mut LambdaExpr| { &mut m.field_return },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LambdaExpr>(
            "LambdaExpr",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for LambdaExpr {
    fn is_initialized(&self) -> bool {
        if self.field_return.is_none() {
            return false;
        }
        for v in &self.field_return {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.field_return)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.field_return.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.args {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.field_return.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> LambdaExpr {
        LambdaExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 11)
    }

    fn default_instance() -> &'static LambdaExpr {
        static instance: LambdaExpr = LambdaExpr {
            args: ::std::vec::Vec::new(),
            field_return: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for LambdaExpr {
    fn clear(&mut self) {
        self.args.clear();
        self.field_return.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LambdaExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LambdaExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct CallExpr {
    // message fields
    pub calling: ::protobuf::MessageField<Expr>,
    pub args: ::std::vec::Vec<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallExpr {
    fn default() -> &'a CallExpr {
        <CallExpr as ::protobuf::Message>::default_instance()
    }
}

impl CallExpr {
    pub fn new() -> CallExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "calling",
            |m: &CallExpr| { &m.calling },
            |m: &mut CallExpr| { &mut m.calling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &CallExpr| { &m.args },
            |m: &mut CallExpr| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallExpr>(
            "CallExpr",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for CallExpr {
    fn is_initialized(&self) -> bool {
        if self.calling.is_none() {
            return false;
        }
        for v in &self.calling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.calling)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.calling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.calling.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> CallExpr {
        CallExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 12)
    }

    fn default_instance() -> &'static CallExpr {
        static instance: CallExpr = CallExpr {
            calling: ::protobuf::MessageField::none(),
            args: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for CallExpr {
    fn clear(&mut self) {
        self.calling.clear();
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Elif {
    // message fields
    pub condition: ::protobuf::MessageField<Expr>,
    pub then: ::protobuf::MessageField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Elif {
    fn default() -> &'a Elif {
        <Elif as ::protobuf::Message>::default_instance()
    }
}

impl Elif {
    pub fn new() -> Elif {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "condition",
            |m: &Elif| { &m.condition },
            |m: &mut Elif| { &mut m.condition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "then",
            |m: &Elif| { &m.then },
            |m: &mut Elif| { &mut m.then },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Elif>(
            "Elif",
            9,
            fields,
        )
    }
}

impl ::protobuf::Message for Elif {
    fn is_initialized(&self) -> bool {
        if self.condition.is_none() {
            return false;
        }
        if self.then.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.condition)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.then)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.condition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Elif {
        Elif::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 13)
    }

    fn default_instance() -> &'static Elif {
        static instance: Elif = Elif {
            condition: ::protobuf::MessageField::none(),
            then: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Elif {
    fn clear(&mut self) {
        self.condition.clear();
        self.then.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Elif {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Elif {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct IfExpr {
    // message fields
    pub condition: ::protobuf::MessageField<Expr>,
    pub then: ::protobuf::MessageField<Expr>,
    pub elif: ::std::vec::Vec<Elif>,
    pub field_else: ::protobuf::MessageField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a IfExpr {
    fn default() -> &'a IfExpr {
        <IfExpr as ::protobuf::Message>::default_instance()
    }
}

impl IfExpr {
    pub fn new() -> IfExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "condition",
            |m: &IfExpr| { &m.condition },
            |m: &mut IfExpr| { &mut m.condition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "then",
            |m: &IfExpr| { &m.then },
            |m: &mut IfExpr| { &mut m.then },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "elif",
            |m: &IfExpr| { &m.elif },
            |m: &mut IfExpr| { &mut m.elif },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "else",
            |m: &IfExpr| { &m.field_else },
            |m: &mut IfExpr| { &mut m.field_else },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IfExpr>(
            "IfExpr",
            10,
            fields,
        )
    }
}

impl ::protobuf::Message for IfExpr {
    fn is_initialized(&self) -> bool {
        if self.condition.is_none() {
            return false;
        }
        if self.then.is_none() {
            return false;
        }
        if self.field_else.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.elif {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_else {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.condition)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.then)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.elif)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.field_else)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.elif {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.field_else.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.condition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.elif {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.field_else.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> IfExpr {
        IfExpr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 14)
    }

    fn default_instance() -> &'static IfExpr {
        static instance: IfExpr = IfExpr {
            condition: ::protobuf::MessageField::none(),
            then: ::protobuf::MessageField::none(),
            elif: ::std::vec::Vec::new(),
            field_else: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for IfExpr {
    fn clear(&mut self) {
        self.condition.clear();
        self.then.clear();
        self.elif.clear();
        self.field_else.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IfExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IfExpr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Position {
    // message fields
    file: ::std::option::Option<::std::string::String>,
    line: ::std::option::Option<i32>,
    column: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // required string file = 1;

    pub fn get_file(&self) -> &str {
        match self.file.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file(&mut self) {
        self.file = ::std::option::Option::None;
    }

    pub fn has_file(&self) -> bool {
        self.file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        if self.file.is_none() {
            self.file = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file.as_mut().unwrap()
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        self.file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 line = 2;

    pub fn get_line(&self) -> i32 {
        self.line.unwrap_or(0)
    }

    pub fn clear_line(&mut self) {
        self.line = ::std::option::Option::None;
    }

    pub fn has_line(&self) -> bool {
        self.line.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: i32) {
        self.line = ::std::option::Option::Some(v);
    }

    // required int32 column = 3;

    pub fn get_column(&self) -> i32 {
        self.column.unwrap_or(0)
    }

    pub fn clear_column(&mut self) {
        self.column = ::std::option::Option::None;
    }

    pub fn has_column(&self) -> bool {
        self.column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: i32) {
        self.column = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "file",
            |m: &Position| { &m.file },
            |m: &mut Position| { &mut m.file },
            Position::get_file,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "line",
            |m: &Position| { &m.line },
            |m: &mut Position| { &mut m.line },
            Position::get_line,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "column",
            |m: &Position| { &m.column },
            |m: &mut Position| { &mut m.column },
            Position::get_column,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            11,
            fields,
        )
    }
}

impl ::protobuf::Message for Position {
    fn is_initialized(&self) -> bool {
        if self.file.is_none() {
            return false;
        }
        if self.line.is_none() {
            return false;
        }
        if self.column.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.line = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.column = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.file.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.line {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.column {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.file.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.line {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.column {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 15)
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            file: ::std::option::Option::None,
            line: ::std::option::Option::None,
            column: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Position {
    fn clear(&mut self) {
        self.file = ::std::option::Option::None;
        self.line = ::std::option::Option::None;
        self.column = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr {
    // message fields
    pub position: ::protobuf::MessageField<Position>,
    // message oneof groups
    pub inner: ::std::option::Option<expr::Inner>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr {
    fn default() -> &'a Expr {
        <Expr as ::protobuf::Message>::default_instance()
    }
}

impl Expr {
    pub fn new() -> Expr {
        ::std::default::Default::default()
    }

    // optional .model.RefExpr ref = 2;

    pub fn get_field_ref(&self) -> &RefExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::field_ref(ref v)) => v,
            _ => <RefExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_field_ref(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_field_ref(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::field_ref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_ref(&mut self, v: RefExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::field_ref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_ref(&mut self) -> &mut RefExpr {
        if let ::std::option::Option::Some(expr::Inner::field_ref(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::field_ref(RefExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::field_ref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_ref(&mut self) -> RefExpr {
        if self.has_field_ref() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::field_ref(v)) => v,
                _ => panic!(),
            }
        } else {
            RefExpr::new()
        }
    }

    // optional .model.LambdaExpr lambda = 3;

    pub fn get_lambda(&self) -> &LambdaExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::lambda(ref v)) => v,
            _ => <LambdaExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_lambda(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_lambda(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::lambda(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lambda(&mut self, v: LambdaExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::lambda(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lambda(&mut self) -> &mut LambdaExpr {
        if let ::std::option::Option::Some(expr::Inner::lambda(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::lambda(LambdaExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::lambda(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lambda(&mut self) -> LambdaExpr {
        if self.has_lambda() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::lambda(v)) => v,
                _ => panic!(),
            }
        } else {
            LambdaExpr::new()
        }
    }

    // optional .model.CallExpr call = 4;

    pub fn get_call(&self) -> &CallExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::call(ref v)) => v,
            _ => <CallExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_call(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_call(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::call(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_call(&mut self, v: CallExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::call(v))
    }

    // Mutable pointer to the field.
    pub fn mut_call(&mut self) -> &mut CallExpr {
        if let ::std::option::Option::Some(expr::Inner::call(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::call(CallExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::call(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_call(&mut self) -> CallExpr {
        if self.has_call() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::call(v)) => v,
                _ => panic!(),
            }
        } else {
            CallExpr::new()
        }
    }

    // optional string string = 5;

    pub fn get_string(&self) -> &str {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::string(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.inner = ::std::option::Option::Some(expr::Inner::string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(expr::Inner::string(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::string(::std::string::String::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional int64 int64 = 6;

    pub fn get_int64(&self) -> i64 {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::int64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int64(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_int64(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64(&mut self, v: i64) {
        self.inner = ::std::option::Option::Some(expr::Inner::int64(v))
    }

    // optional int32 int32 = 7;

    pub fn get_int32(&self) -> i32 {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::int32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int32(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_int32(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::int32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int32(&mut self, v: i32) {
        self.inner = ::std::option::Option::Some(expr::Inner::int32(v))
    }

    // optional float float = 8;

    pub fn get_float(&self) -> f32 {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::float(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_float(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: f32) {
        self.inner = ::std::option::Option::Some(expr::Inner::float(v))
    }

    // optional bool bool = 9;

    pub fn get_bool(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::bool(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.inner = ::std::option::Option::Some(expr::Inner::bool(v))
    }

    // optional .model.HouseExpr house = 10;

    pub fn get_house(&self) -> &HouseExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::house(ref v)) => v,
            _ => <HouseExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_house(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_house(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::house(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_house(&mut self, v: HouseExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::house(v))
    }

    // Mutable pointer to the field.
    pub fn mut_house(&mut self) -> &mut HouseExpr {
        if let ::std::option::Option::Some(expr::Inner::house(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::house(HouseExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::house(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_house(&mut self) -> HouseExpr {
        if self.has_house() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::house(v)) => v,
                _ => panic!(),
            }
        } else {
            HouseExpr::new()
        }
    }

    // optional .model.RoomExpr room = 11;

    pub fn get_room(&self) -> &RoomExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::room(ref v)) => v,
            _ => <RoomExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_room(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_room(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::room(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_room(&mut self, v: RoomExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::room(v))
    }

    // Mutable pointer to the field.
    pub fn mut_room(&mut self) -> &mut RoomExpr {
        if let ::std::option::Option::Some(expr::Inner::room(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::room(RoomExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::room(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_room(&mut self) -> RoomExpr {
        if self.has_room() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::room(v)) => v,
                _ => panic!(),
            }
        } else {
            RoomExpr::new()
        }
    }

    // optional .model.ControllerExpr controller = 12;

    pub fn get_controller(&self) -> &ControllerExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::controller(ref v)) => v,
            _ => <ControllerExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_controller(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::controller(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: ControllerExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::controller(v))
    }

    // Mutable pointer to the field.
    pub fn mut_controller(&mut self) -> &mut ControllerExpr {
        if let ::std::option::Option::Some(expr::Inner::controller(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::controller(ControllerExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::controller(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_controller(&mut self) -> ControllerExpr {
        if self.has_controller() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::controller(v)) => v,
                _ => panic!(),
            }
        } else {
            ControllerExpr::new()
        }
    }

    // optional .model.DisplayInterfaceExpr display_interface = 13;

    pub fn get_display_interface(&self) -> &DisplayInterfaceExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::display_interface(ref v)) => v,
            _ => <DisplayInterfaceExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_display_interface(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_display_interface(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::display_interface(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_display_interface(&mut self, v: DisplayInterfaceExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::display_interface(v))
    }

    // Mutable pointer to the field.
    pub fn mut_display_interface(&mut self) -> &mut DisplayInterfaceExpr {
        if let ::std::option::Option::Some(expr::Inner::display_interface(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::display_interface(DisplayInterfaceExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::display_interface(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_display_interface(&mut self) -> DisplayInterfaceExpr {
        if self.has_display_interface() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::display_interface(v)) => v,
                _ => panic!(),
            }
        } else {
            DisplayInterfaceExpr::new()
        }
    }

    // optional .model.DeviceExpr device = 14;

    pub fn get_device(&self) -> &DeviceExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::device(ref v)) => v,
            _ => <DeviceExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::device(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: DeviceExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::device(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device(&mut self) -> &mut DeviceExpr {
        if let ::std::option::Option::Some(expr::Inner::device(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::device(DeviceExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::device(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device(&mut self) -> DeviceExpr {
        if self.has_device() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::device(v)) => v,
                _ => panic!(),
            }
        } else {
            DeviceExpr::new()
        }
    }

    // optional .model.WidgetExpr widget = 15;

    pub fn get_widget(&self) -> &WidgetExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::widget(ref v)) => v,
            _ => <WidgetExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_widget(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_widget(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::widget(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_widget(&mut self, v: WidgetExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::widget(v))
    }

    // Mutable pointer to the field.
    pub fn mut_widget(&mut self) -> &mut WidgetExpr {
        if let ::std::option::Option::Some(expr::Inner::widget(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::widget(WidgetExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::widget(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_widget(&mut self) -> WidgetExpr {
        if self.has_widget() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::widget(v)) => v,
                _ => panic!(),
            }
        } else {
            WidgetExpr::new()
        }
    }

    // optional .model.IfExpr if = 16;

    pub fn get_field_if(&self) -> &IfExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::field_if(ref v)) => v,
            _ => <IfExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_field_if(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_field_if(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::field_if(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_if(&mut self, v: IfExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::field_if(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_if(&mut self) -> &mut IfExpr {
        if let ::std::option::Option::Some(expr::Inner::field_if(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::field_if(IfExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::field_if(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_if(&mut self) -> IfExpr {
        if self.has_field_if() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::field_if(v)) => v,
                _ => panic!(),
            }
        } else {
            IfExpr::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "position",
            |m: &Expr| { &m.position },
            |m: &mut Expr| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RefExpr>(
            "ref",
            Expr::has_field_ref,
            Expr::get_field_ref,
            Expr::mut_field_ref,
            Expr::set_field_ref,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LambdaExpr>(
            "lambda",
            Expr::has_lambda,
            Expr::get_lambda,
            Expr::mut_lambda,
            Expr::set_lambda,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CallExpr>(
            "call",
            Expr::has_call,
            Expr::get_call,
            Expr::mut_call,
            Expr::set_call,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string",
            Expr::has_string,
            Expr::get_string,
            Expr::set_string,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int64",
            Expr::has_int64,
            Expr::get_int64,
            Expr::set_int64,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int32",
            Expr::has_int32,
            Expr::get_int32,
            Expr::set_int32,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "float",
            Expr::has_float,
            Expr::get_float,
            Expr::set_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool",
            Expr::has_bool,
            Expr::get_bool,
            Expr::set_bool,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HouseExpr>(
            "house",
            Expr::has_house,
            Expr::get_house,
            Expr::mut_house,
            Expr::set_house,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RoomExpr>(
            "room",
            Expr::has_room,
            Expr::get_room,
            Expr::mut_room,
            Expr::set_room,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ControllerExpr>(
            "controller",
            Expr::has_controller,
            Expr::get_controller,
            Expr::mut_controller,
            Expr::set_controller,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DisplayInterfaceExpr>(
            "display_interface",
            Expr::has_display_interface,
            Expr::get_display_interface,
            Expr::mut_display_interface,
            Expr::set_display_interface,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeviceExpr>(
            "device",
            Expr::has_device,
            Expr::get_device,
            Expr::mut_device,
            Expr::set_device,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WidgetExpr>(
            "widget",
            Expr::has_widget,
            Expr::get_widget,
            Expr::mut_widget,
            Expr::set_widget,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, IfExpr>(
            "if",
            Expr::has_field_if,
            Expr::get_field_if,
            Expr::mut_field_if,
            Expr::set_field_if,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Expr>(
            "Expr",
            12,
            fields,
        )
    }
}

impl ::protobuf::Message for Expr {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(expr::Inner::field_ref(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::lambda(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::call(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::house(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::room(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::controller(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::display_interface(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::device(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::widget(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::field_if(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.position)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::field_ref(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::lambda(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::call(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::string(is.read_string()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::int64(is.read_int64()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::int32(is.read_int32()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::float(is.read_float()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::bool(is.read_bool()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::house(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::room(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::controller(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::display_interface(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::device(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::widget(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.inner = ::std::option::Option::Some(expr::Inner::field_if(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &expr::Inner::field_ref(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::lambda(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::call(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::string(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &expr::Inner::int64(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &expr::Inner::int32(v) => {
                    my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &expr::Inner::float(v) => {
                    my_size += 5;
                },
                &expr::Inner::bool(v) => {
                    my_size += 2;
                },
                &expr::Inner::house(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::room(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::controller(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::display_interface(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::device(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::widget(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &expr::Inner::field_if(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &expr::Inner::field_ref(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &expr::Inner::lambda(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &expr::Inner::call(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &expr::Inner::string(ref v) => {
                    os.write_string(5, v)?;
                },
                &expr::Inner::int64(v) => {
                    os.write_int64(6, v)?;
                },
                &expr::Inner::int32(v) => {
                    os.write_int32(7, v)?;
                },
                &expr::Inner::float(v) => {
                    os.write_float(8, v)?;
                },
                &expr::Inner::bool(v) => {
                    os.write_bool(9, v)?;
                },
                &expr::Inner::house(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &expr::Inner::room(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &expr::Inner::controller(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &expr::Inner::display_interface(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &expr::Inner::device(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &expr::Inner::widget(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &expr::Inner::field_if(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Expr {
        Expr::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 16)
    }

    fn default_instance() -> &'static Expr {
        static instance: Expr = Expr {
            position: ::protobuf::MessageField::none(),
            inner: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Expr {
    fn clear(&mut self) {
        self.position.clear();
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Expr`
pub mod expr {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Inner {
        field_ref(super::RefExpr),
        lambda(super::LambdaExpr),
        call(super::CallExpr),
        string(::std::string::String),
        int64(i64),
        int32(i32),
        float(f32),
        bool(bool),
        house(super::HouseExpr),
        room(super::RoomExpr),
        controller(super::ControllerExpr),
        display_interface(super::DisplayInterfaceExpr),
        device(super::DeviceExpr),
        widget(super::WidgetExpr),
        field_if(super::IfExpr),
    }

    impl ::protobuf::Oneof for Inner {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Module {
    // message fields
    pub imports: ::std::collections::HashMap<::std::string::String, Module>,
    pub body: ::protobuf::MessageField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "imports",
            |m: &Module| { &m.imports },
            |m: &mut Module| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "body",
            |m: &Module| { &m.body },
            |m: &mut Module| { &mut m.body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Module>(
            "Module",
            13,
            fields,
        )
    }
}

impl ::protobuf::Message for Module {
    fn is_initialized(&self) -> bool {
        if self.body.is_none() {
            return false;
        }
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Module>>(wire_type, is, &mut self.imports)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Module>>(1, &self.imports);
        if let Some(v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::reflect::types::ProtobufTypeString, ::protobuf::reflect::types::ProtobufTypeMessage<Module>>(1, &self.imports, os)?;
        if let Some(v) = self.body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Module {
        Module::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 17)
    }

    fn default_instance() -> &'static Module {
        static instance: ::protobuf::rt::LazyV2<Module> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Module::new)
    }
}

impl ::protobuf::Clear for Module {
    fn clear(&mut self) {
        self.imports.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17OpenControllerLib.proto\x12\x05model\"\xd2\x01\n\tHouseExpr\x12.\n\
    \x0cdisplay_name\x18\x01\x20\x02(\x0b2\x0b.model.ExprR\x0bdisplayName\
    \x12\x1b\n\x02id\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\x02id\x121\n\x05r\
    ooms\x18\x03\x20\x03(\x0b2\x1b.model.HouseExpr.RoomsEntryR\x05rooms\x1aE\
    \n\nRoomsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12!\n\x05val\
    ue\x18\x02\x20\x01(\x0b2\x0b.model.ExprR\x05value:\x028\x01\"\xec\x01\n\
    \x08RoomExpr\x12.\n\x0cdisplay_name\x18\x01\x20\x02(\x0b2\x0b.model.Expr\
    R\x0bdisplayName\x12B\n\x0bcontrollers\x18\x02\x20\x03(\x0b2\x20.model.R\
    oomExpr.ControllersEntryR\x0bcontrollers\x12\x1f\n\x04icon\x18\x03\x20\
    \x01(\x0b2\x0b.model.ExprR\x04icon\x1aK\n\x10ControllersEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12!\n\x05value\x18\x02\x20\x01(\x0b2\
    \x0b.model.ExprR\x05value:\x028\x01\"\xa8\x01\n\x0eControllerExpr\x12.\n\
    \x0cdisplay_name\x18\x01\x20\x02(\x0b2\x0b.model.ExprR\x0bdisplayName\
    \x12,\n\x0bbrand_color\x18\x02\x20\x01(\x0b2\x0b.model.ExprR\nbrandColor\
    \x128\n\x11display_interface\x18\x03\x20\x01(\x0b2\x0b.model.ExprR\x10di\
    splayInterface\"=\n\x14DisplayInterfaceExpr\x12%\n\x07widgets\x18\x01\
    \x20\x03(\x0b2\x0b.model.ExprR\x07widgets\"\x8f\x01\n\nDeviceExpr\x128\n\
    \x07lambdas\x18\x01\x20\x03(\x0b2\x1e.model.DeviceExpr.LambdasEntryR\x07\
    lambdas\x1aG\n\x0cLambdasEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12!\n\x05value\x18\x02\x20\x01(\x0b2\x0b.model.ExprR\x05value:\x028\
    \x01\"\xd5\x01\n\nWidgetExpr\x12\x1f\n\x0bwidget_type\x18\x02\x20\x02(\t\
    R\nwidgetType\x125\n\x06params\x18\x03\x20\x03(\x0b2\x1d.model.WidgetExp\
    r.ParamsEntryR\x06params\x12'\n\x08children\x18\x04\x20\x03(\x0b2\x0b.mo\
    del.ExprR\x08children\x1aF\n\x0bParamsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12!\n\x05value\x18\x02\x20\x01(\x0b2\x0b.model.ExprR\
    \x05value:\x028\x01\"\x1b\n\x07RefExpr\x12\x10\n\x03ref\x18\x01\x20\x02(\
    \tR\x03ref\"E\n\nLambdaExpr\x12\x12\n\x04args\x18\x01\x20\x03(\tR\x04arg\
    s\x12#\n\x06return\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\x06return\"R\n\
    \x08CallExpr\x12%\n\x07calling\x18\x01\x20\x02(\x0b2\x0b.model.ExprR\x07\
    calling\x12\x1f\n\x04args\x18\x02\x20\x03(\x0b2\x0b.model.ExprR\x04args\
    \"R\n\x04Elif\x12)\n\tcondition\x18\x01\x20\x02(\x0b2\x0b.model.ExprR\tc\
    ondition\x12\x1f\n\x04then\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\x04then\
    \"\x96\x01\n\x06IfExpr\x12)\n\tcondition\x18\x01\x20\x02(\x0b2\x0b.model\
    .ExprR\tcondition\x12\x1f\n\x04then\x18\x02\x20\x02(\x0b2\x0b.model.Expr\
    R\x04then\x12\x1f\n\x04elif\x18\x03\x20\x03(\x0b2\x0b.model.ElifR\x04eli\
    f\x12\x1f\n\x04else\x18\x04\x20\x02(\x0b2\x0b.model.ExprR\x04else\"J\n\
    \x08Position\x12\x12\n\x04file\x18\x01\x20\x02(\tR\x04file\x12\x12\n\x04\
    line\x18\x02\x20\x02(\x05R\x04line\x12\x16\n\x06column\x18\x03\x20\x02(\
    \x05R\x06column\"\xfd\x04\n\x04Expr\x12+\n\x08position\x18\x01\x20\x01(\
    \x0b2\x0f.model.PositionR\x08position\x12\"\n\x03ref\x18\x02\x20\x01(\
    \x0b2\x0e.model.RefExprH\0R\x03ref\x12+\n\x06lambda\x18\x03\x20\x01(\x0b\
    2\x11.model.LambdaExprH\0R\x06lambda\x12%\n\x04call\x18\x04\x20\x01(\x0b\
    2\x0f.model.CallExprH\0R\x04call\x12\x18\n\x06string\x18\x05\x20\x01(\tH\
    \0R\x06string\x12\x16\n\x05int64\x18\x06\x20\x01(\x03H\0R\x05int64\x12\
    \x16\n\x05int32\x18\x07\x20\x01(\x05H\0R\x05int32\x12\x16\n\x05float\x18\
    \x08\x20\x01(\x02H\0R\x05float\x12\x14\n\x04bool\x18\t\x20\x01(\x08H\0R\
    \x04bool\x12(\n\x05house\x18\n\x20\x01(\x0b2\x10.model.HouseExprH\0R\x05\
    house\x12%\n\x04room\x18\x0b\x20\x01(\x0b2\x0f.model.RoomExprH\0R\x04roo\
    m\x127\n\ncontroller\x18\x0c\x20\x01(\x0b2\x15.model.ControllerExprH\0R\
    \ncontroller\x12J\n\x11display_interface\x18\r\x20\x01(\x0b2\x1b.model.D\
    isplayInterfaceExprH\0R\x10displayInterface\x12+\n\x06device\x18\x0e\x20\
    \x01(\x0b2\x11.model.DeviceExprH\0R\x06device\x12+\n\x06widget\x18\x0f\
    \x20\x01(\x0b2\x11.model.WidgetExprH\0R\x06widget\x12\x1f\n\x02if\x18\
    \x10\x20\x01(\x0b2\r.model.IfExprH\0R\x02ifB\x07\n\x05inner\"\xaa\x01\n\
    \x06Module\x124\n\x07imports\x18\x01\x20\x03(\x0b2\x1a.model.Module.Impo\
    rtsEntryR\x07imports\x12\x1f\n\x04body\x18\x02\x20\x02(\x0b2\x0b.model.E\
    xprR\x04body\x1aI\n\x0cImportsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12#\n\x05value\x18\x02\x20\x01(\x0b2\r.model.ModuleR\x05value:\
    \x028\x01BR\n&com.pjtsearch.opencontroller_lib_protoP\x01Z&pjtsearch.com\
    /opencontroller_lib_proto\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(HouseExpr::generated_message_descriptor_data());
        messages.push(RoomExpr::generated_message_descriptor_data());
        messages.push(ControllerExpr::generated_message_descriptor_data());
        messages.push(DisplayInterfaceExpr::generated_message_descriptor_data());
        messages.push(DeviceExpr::generated_message_descriptor_data());
        messages.push(WidgetExpr::generated_message_descriptor_data());
        messages.push(RefExpr::generated_message_descriptor_data());
        messages.push(LambdaExpr::generated_message_descriptor_data());
        messages.push(CallExpr::generated_message_descriptor_data());
        messages.push(Elif::generated_message_descriptor_data());
        messages.push(IfExpr::generated_message_descriptor_data());
        messages.push(Position::generated_message_descriptor_data());
        messages.push(Expr::generated_message_descriptor_data());
        messages.push(Module::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
