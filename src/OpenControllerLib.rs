// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `OpenControllerLib.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:model.HouseExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HouseExpr {
    // message fields
    // @@protoc_insertion_point(field:model.HouseExpr.display_name)
    pub display_name: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.HouseExpr.id)
    pub id: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.HouseExpr.rooms)
    pub rooms: ::std::vec::Vec<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.HouseExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HouseExpr {
    fn default() -> &'a HouseExpr {
        <HouseExpr as ::protobuf::Message>::default_instance()
    }
}

impl HouseExpr {
    pub fn new() -> HouseExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_name",
            |m: &HouseExpr| { &m.display_name },
            |m: &mut HouseExpr| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "id",
            |m: &HouseExpr| { &m.id },
            |m: &mut HouseExpr| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rooms",
            |m: &HouseExpr| { &m.rooms },
            |m: &mut HouseExpr| { &mut m.rooms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HouseExpr>(
            "HouseExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HouseExpr {
    const NAME: &'static str = "HouseExpr";

    fn is_initialized(&self) -> bool {
        if self.display_name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.display_name)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                26 => {
                    self.rooms.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.display_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.rooms {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HouseExpr {
        HouseExpr::new()
    }

    fn clear(&mut self) {
        self.display_name.clear();
        self.id.clear();
        self.rooms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HouseExpr {
        static instance: HouseExpr = HouseExpr {
            display_name: ::protobuf::MessageField::none(),
            id: ::protobuf::MessageField::none(),
            rooms: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HouseExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HouseExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HouseExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HouseExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.RoomExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RoomExpr {
    // message fields
    // @@protoc_insertion_point(field:model.RoomExpr.id)
    pub id: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.RoomExpr.display_name)
    pub display_name: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.RoomExpr.controllers)
    pub controllers: ::std::vec::Vec<Expr>,
    // @@protoc_insertion_point(field:model.RoomExpr.icon)
    pub icon: ::protobuf::MessageField<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.RoomExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoomExpr {
    fn default() -> &'a RoomExpr {
        <RoomExpr as ::protobuf::Message>::default_instance()
    }
}

impl RoomExpr {
    pub fn new() -> RoomExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "id",
            |m: &RoomExpr| { &m.id },
            |m: &mut RoomExpr| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_name",
            |m: &RoomExpr| { &m.display_name },
            |m: &mut RoomExpr| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controllers",
            |m: &RoomExpr| { &m.controllers },
            |m: &mut RoomExpr| { &mut m.controllers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "icon",
            |m: &RoomExpr| { &m.icon },
            |m: &mut RoomExpr| { &mut m.icon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoomExpr>(
            "RoomExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoomExpr {
    const NAME: &'static str = "RoomExpr";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.display_name.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.controllers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.icon {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.display_name)?;
                },
                26 => {
                    self.controllers.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.controllers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.controllers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.icon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoomExpr {
        RoomExpr::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.display_name.clear();
        self.controllers.clear();
        self.icon.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoomExpr {
        static instance: RoomExpr = RoomExpr {
            id: ::protobuf::MessageField::none(),
            display_name: ::protobuf::MessageField::none(),
            controllers: ::std::vec::Vec::new(),
            icon: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoomExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoomExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoomExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.ControllerExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerExpr {
    // message fields
    // @@protoc_insertion_point(field:model.ControllerExpr.id)
    pub id: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.ControllerExpr.display_name)
    pub display_name: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.ControllerExpr.brand_color)
    pub brand_color: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.ControllerExpr.display_interface)
    pub display_interface: ::protobuf::MessageField<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.ControllerExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerExpr {
    fn default() -> &'a ControllerExpr {
        <ControllerExpr as ::protobuf::Message>::default_instance()
    }
}

impl ControllerExpr {
    pub fn new() -> ControllerExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "id",
            |m: &ControllerExpr| { &m.id },
            |m: &mut ControllerExpr| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_name",
            |m: &ControllerExpr| { &m.display_name },
            |m: &mut ControllerExpr| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "brand_color",
            |m: &ControllerExpr| { &m.brand_color },
            |m: &mut ControllerExpr| { &mut m.brand_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "display_interface",
            |m: &ControllerExpr| { &m.display_interface },
            |m: &mut ControllerExpr| { &mut m.display_interface },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerExpr>(
            "ControllerExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControllerExpr {
    const NAME: &'static str = "ControllerExpr";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.display_name.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.brand_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display_interface {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.display_name)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.brand_color)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.display_interface)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.brand_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.display_interface.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.brand_color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.display_interface.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerExpr {
        ControllerExpr::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.display_name.clear();
        self.brand_color.clear();
        self.display_interface.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerExpr {
        static instance: ControllerExpr = ControllerExpr {
            id: ::protobuf::MessageField::none(),
            display_name: ::protobuf::MessageField::none(),
            brand_color: ::protobuf::MessageField::none(),
            display_interface: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControllerExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControllerExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControllerExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.DisplayInterfaceExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DisplayInterfaceExpr {
    // message fields
    // @@protoc_insertion_point(field:model.DisplayInterfaceExpr.widgets)
    pub widgets: ::std::vec::Vec<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.DisplayInterfaceExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisplayInterfaceExpr {
    fn default() -> &'a DisplayInterfaceExpr {
        <DisplayInterfaceExpr as ::protobuf::Message>::default_instance()
    }
}

impl DisplayInterfaceExpr {
    pub fn new() -> DisplayInterfaceExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "widgets",
            |m: &DisplayInterfaceExpr| { &m.widgets },
            |m: &mut DisplayInterfaceExpr| { &mut m.widgets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayInterfaceExpr>(
            "DisplayInterfaceExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisplayInterfaceExpr {
    const NAME: &'static str = "DisplayInterfaceExpr";

    fn is_initialized(&self) -> bool {
        for v in &self.widgets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.widgets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.widgets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.widgets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisplayInterfaceExpr {
        DisplayInterfaceExpr::new()
    }

    fn clear(&mut self) {
        self.widgets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisplayInterfaceExpr {
        static instance: DisplayInterfaceExpr = DisplayInterfaceExpr {
            widgets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisplayInterfaceExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisplayInterfaceExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisplayInterfaceExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayInterfaceExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.DeviceExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceExpr {
    // message fields
    // @@protoc_insertion_point(field:model.DeviceExpr.lambdas)
    pub lambdas: ::std::collections::HashMap<::std::string::String, Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.DeviceExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceExpr {
    fn default() -> &'a DeviceExpr {
        <DeviceExpr as ::protobuf::Message>::default_instance()
    }
}

impl DeviceExpr {
    pub fn new() -> DeviceExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "lambdas",
            |m: &DeviceExpr| { &m.lambdas },
            |m: &mut DeviceExpr| { &mut m.lambdas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceExpr>(
            "DeviceExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceExpr {
    const NAME: &'static str = "DeviceExpr";

    fn is_initialized(&self) -> bool {
        // TODO: check map values are initialized
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.lambdas.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.lambdas {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.lambdas {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceExpr {
        DeviceExpr::new()
    }

    fn clear(&mut self) {
        self.lambdas.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceExpr {
        static instance: ::protobuf::rt::Lazy<DeviceExpr> = ::protobuf::rt::Lazy::new();
        instance.get(DeviceExpr::new)
    }
}

impl ::protobuf::MessageFull for DeviceExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.WidgetExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WidgetExpr {
    // message fields
    // @@protoc_insertion_point(field:model.WidgetExpr.widget_type)
    pub widget_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:model.WidgetExpr.params)
    pub params: ::std::collections::HashMap<::std::string::String, Expr>,
    // @@protoc_insertion_point(field:model.WidgetExpr.children)
    pub children: ::std::vec::Vec<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.WidgetExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WidgetExpr {
    fn default() -> &'a WidgetExpr {
        <WidgetExpr as ::protobuf::Message>::default_instance()
    }
}

impl WidgetExpr {
    pub fn new() -> WidgetExpr {
        ::std::default::Default::default()
    }

    // required string widget_type = 2;

    pub fn widget_type(&self) -> &str {
        match self.widget_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_widget_type(&mut self) {
        self.widget_type = ::std::option::Option::None;
    }

    pub fn has_widget_type(&self) -> bool {
        self.widget_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_widget_type(&mut self, v: ::std::string::String) {
        self.widget_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_widget_type(&mut self) -> &mut ::std::string::String {
        if self.widget_type.is_none() {
            self.widget_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.widget_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_widget_type(&mut self) -> ::std::string::String {
        self.widget_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "widget_type",
            |m: &WidgetExpr| { &m.widget_type },
            |m: &mut WidgetExpr| { &mut m.widget_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "params",
            |m: &WidgetExpr| { &m.params },
            |m: &mut WidgetExpr| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "children",
            |m: &WidgetExpr| { &m.children },
            |m: &mut WidgetExpr| { &mut m.children },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WidgetExpr>(
            "WidgetExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WidgetExpr {
    const NAME: &'static str = "WidgetExpr";

    fn is_initialized(&self) -> bool {
        if self.widget_type.is_none() {
            return false;
        }
        // TODO: check map values are initialized
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.widget_type = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.params.insert(key, value);
                },
                34 => {
                    self.children.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.widget_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for (k, v) in &self.params {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.widget_type.as_ref() {
            os.write_string(2, v)?;
        }
        for (k, v) in &self.params {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WidgetExpr {
        WidgetExpr::new()
    }

    fn clear(&mut self) {
        self.widget_type = ::std::option::Option::None;
        self.params.clear();
        self.children.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WidgetExpr {
        static instance: ::protobuf::rt::Lazy<WidgetExpr> = ::protobuf::rt::Lazy::new();
        instance.get(WidgetExpr::new)
    }
}

impl ::protobuf::MessageFull for WidgetExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WidgetExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WidgetExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WidgetExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.RefExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RefExpr {
    // message fields
    // @@protoc_insertion_point(field:model.RefExpr.ref)
    pub ref_: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:model.RefExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RefExpr {
    fn default() -> &'a RefExpr {
        <RefExpr as ::protobuf::Message>::default_instance()
    }
}

impl RefExpr {
    pub fn new() -> RefExpr {
        ::std::default::Default::default()
    }

    // required string ref = 1;

    pub fn ref_(&self) -> &str {
        match self.ref_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ref_(&mut self) {
        self.ref_ = ::std::option::Option::None;
    }

    pub fn has_ref(&self) -> bool {
        self.ref_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref(&mut self, v: ::std::string::String) {
        self.ref_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref(&mut self) -> &mut ::std::string::String {
        if self.ref_.is_none() {
            self.ref_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ref_.as_mut().unwrap()
    }

    // Take field
    pub fn take_ref_(&mut self) -> ::std::string::String {
        self.ref_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ref",
            |m: &RefExpr| { &m.ref_ },
            |m: &mut RefExpr| { &mut m.ref_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefExpr>(
            "RefExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RefExpr {
    const NAME: &'static str = "RefExpr";

    fn is_initialized(&self) -> bool {
        if self.ref_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ref_ = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ref_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ref_.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RefExpr {
        RefExpr::new()
    }

    fn clear(&mut self) {
        self.ref_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RefExpr {
        static instance: RefExpr = RefExpr {
            ref_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RefExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RefExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RefExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.LambdaExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LambdaExpr {
    // message fields
    // @@protoc_insertion_point(field:model.LambdaExpr.args)
    pub args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:model.LambdaExpr.return)
    pub return_: ::protobuf::MessageField<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.LambdaExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LambdaExpr {
    fn default() -> &'a LambdaExpr {
        <LambdaExpr as ::protobuf::Message>::default_instance()
    }
}

impl LambdaExpr {
    pub fn new() -> LambdaExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &LambdaExpr| { &m.args },
            |m: &mut LambdaExpr| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "return",
            |m: &LambdaExpr| { &m.return_ },
            |m: &mut LambdaExpr| { &mut m.return_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LambdaExpr>(
            "LambdaExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LambdaExpr {
    const NAME: &'static str = "LambdaExpr";

    fn is_initialized(&self) -> bool {
        if self.return_.is_none() {
            return false;
        }
        for v in &self.return_ {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.args.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.return_)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.return_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.args {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.return_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LambdaExpr {
        LambdaExpr::new()
    }

    fn clear(&mut self) {
        self.args.clear();
        self.return_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LambdaExpr {
        static instance: LambdaExpr = LambdaExpr {
            args: ::std::vec::Vec::new(),
            return_: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LambdaExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LambdaExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LambdaExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LambdaExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.CallExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CallExpr {
    // message fields
    // @@protoc_insertion_point(field:model.CallExpr.calling)
    pub calling: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.CallExpr.args)
    pub args: ::std::vec::Vec<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.CallExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CallExpr {
    fn default() -> &'a CallExpr {
        <CallExpr as ::protobuf::Message>::default_instance()
    }
}

impl CallExpr {
    pub fn new() -> CallExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "calling",
            |m: &CallExpr| { &m.calling },
            |m: &mut CallExpr| { &mut m.calling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &CallExpr| { &m.args },
            |m: &mut CallExpr| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallExpr>(
            "CallExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CallExpr {
    const NAME: &'static str = "CallExpr";

    fn is_initialized(&self) -> bool {
        if self.calling.is_none() {
            return false;
        }
        for v in &self.calling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.calling)?;
                },
                18 => {
                    self.args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.calling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.calling.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CallExpr {
        CallExpr::new()
    }

    fn clear(&mut self) {
        self.calling.clear();
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CallExpr {
        static instance: CallExpr = CallExpr {
            calling: ::protobuf::MessageField::none(),
            args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CallExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CallExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.Elif)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Elif {
    // message fields
    // @@protoc_insertion_point(field:model.Elif.condition)
    pub condition: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.Elif.then)
    pub then: ::protobuf::MessageField<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.Elif.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Elif {
    fn default() -> &'a Elif {
        <Elif as ::protobuf::Message>::default_instance()
    }
}

impl Elif {
    pub fn new() -> Elif {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "condition",
            |m: &Elif| { &m.condition },
            |m: &mut Elif| { &mut m.condition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "then",
            |m: &Elif| { &m.then },
            |m: &mut Elif| { &mut m.then },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Elif>(
            "Elif",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Elif {
    const NAME: &'static str = "Elif";

    fn is_initialized(&self) -> bool {
        if self.condition.is_none() {
            return false;
        }
        if self.then.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.condition)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.then)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.condition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Elif {
        Elif::new()
    }

    fn clear(&mut self) {
        self.condition.clear();
        self.then.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Elif {
        static instance: Elif = Elif {
            condition: ::protobuf::MessageField::none(),
            then: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Elif {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Elif").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Elif {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Elif {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.IfExpr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IfExpr {
    // message fields
    // @@protoc_insertion_point(field:model.IfExpr.condition)
    pub condition: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.IfExpr.then)
    pub then: ::protobuf::MessageField<Expr>,
    // @@protoc_insertion_point(field:model.IfExpr.elif)
    pub elif: ::std::vec::Vec<Elif>,
    // @@protoc_insertion_point(field:model.IfExpr.else)
    pub else_: ::protobuf::MessageField<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.IfExpr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IfExpr {
    fn default() -> &'a IfExpr {
        <IfExpr as ::protobuf::Message>::default_instance()
    }
}

impl IfExpr {
    pub fn new() -> IfExpr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "condition",
            |m: &IfExpr| { &m.condition },
            |m: &mut IfExpr| { &mut m.condition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "then",
            |m: &IfExpr| { &m.then },
            |m: &mut IfExpr| { &mut m.then },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "elif",
            |m: &IfExpr| { &m.elif },
            |m: &mut IfExpr| { &mut m.elif },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "else",
            |m: &IfExpr| { &m.else_ },
            |m: &mut IfExpr| { &mut m.else_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IfExpr>(
            "IfExpr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IfExpr {
    const NAME: &'static str = "IfExpr";

    fn is_initialized(&self) -> bool {
        if self.condition.is_none() {
            return false;
        }
        if self.then.is_none() {
            return false;
        }
        if self.else_.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.elif {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.else_ {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.condition)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.then)?;
                },
                26 => {
                    self.elif.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.else_)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.elif {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.else_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.condition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.elif {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.else_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IfExpr {
        IfExpr::new()
    }

    fn clear(&mut self) {
        self.condition.clear();
        self.then.clear();
        self.elif.clear();
        self.else_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IfExpr {
        static instance: IfExpr = IfExpr {
            condition: ::protobuf::MessageField::none(),
            then: ::protobuf::MessageField::none(),
            elif: ::std::vec::Vec::new(),
            else_: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IfExpr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IfExpr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IfExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IfExpr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Position {
    // message fields
    // @@protoc_insertion_point(field:model.Position.file)
    pub file: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:model.Position.line)
    pub line: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:model.Position.column)
    pub column: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:model.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // required string file = 1;

    pub fn file(&self) -> &str {
        match self.file.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file(&mut self) {
        self.file = ::std::option::Option::None;
    }

    pub fn has_file(&self) -> bool {
        self.file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        if self.file.is_none() {
            self.file = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file.as_mut().unwrap()
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        self.file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 line = 2;

    pub fn line(&self) -> i32 {
        self.line.unwrap_or(0)
    }

    pub fn clear_line(&mut self) {
        self.line = ::std::option::Option::None;
    }

    pub fn has_line(&self) -> bool {
        self.line.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: i32) {
        self.line = ::std::option::Option::Some(v);
    }

    // required int32 column = 3;

    pub fn column(&self) -> i32 {
        self.column.unwrap_or(0)
    }

    pub fn clear_column(&mut self) {
        self.column = ::std::option::Option::None;
    }

    pub fn has_column(&self) -> bool {
        self.column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: i32) {
        self.column = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file",
            |m: &Position| { &m.file },
            |m: &mut Position| { &mut m.file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "line",
            |m: &Position| { &m.line },
            |m: &mut Position| { &mut m.line },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "column",
            |m: &Position| { &m.column },
            |m: &mut Position| { &mut m.column },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        if self.file.is_none() {
            return false;
        }
        if self.line.is_none() {
            return false;
        }
        if self.column.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.line = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.column = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.line {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.column {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.line {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.column {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.file = ::std::option::Option::None;
        self.line = ::std::option::Option::None;
        self.column = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            file: ::std::option::Option::None,
            line: ::std::option::Option::None,
            column: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:model.Expr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Expr {
    // message fields
    // @@protoc_insertion_point(field:model.Expr.position)
    pub position: ::protobuf::MessageField<Position>,
    // message oneof groups
    pub inner: ::std::option::Option<expr::Inner>,
    // special fields
    // @@protoc_insertion_point(special_field:model.Expr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Expr {
    fn default() -> &'a Expr {
        <Expr as ::protobuf::Message>::default_instance()
    }
}

impl Expr {
    pub fn new() -> Expr {
        ::std::default::Default::default()
    }

    // optional .model.RefExpr ref = 2;

    pub fn ref_(&self) -> &RefExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Ref(ref v)) => v,
            _ => <RefExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ref_(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_ref(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Ref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ref(&mut self, v: RefExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::Ref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ref(&mut self) -> &mut RefExpr {
        if let ::std::option::Option::Some(expr::Inner::Ref(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::Ref(RefExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Ref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ref_(&mut self) -> RefExpr {
        if self.has_ref() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::Ref(v)) => v,
                _ => panic!(),
            }
        } else {
            RefExpr::new()
        }
    }

    // optional .model.LambdaExpr lambda = 3;

    pub fn lambda(&self) -> &LambdaExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Lambda(ref v)) => v,
            _ => <LambdaExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_lambda(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_lambda(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Lambda(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lambda(&mut self, v: LambdaExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::Lambda(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lambda(&mut self) -> &mut LambdaExpr {
        if let ::std::option::Option::Some(expr::Inner::Lambda(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::Lambda(LambdaExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Lambda(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lambda(&mut self) -> LambdaExpr {
        if self.has_lambda() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::Lambda(v)) => v,
                _ => panic!(),
            }
        } else {
            LambdaExpr::new()
        }
    }

    // optional .model.CallExpr call = 4;

    pub fn call(&self) -> &CallExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Call(ref v)) => v,
            _ => <CallExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_call(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_call(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Call(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_call(&mut self, v: CallExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::Call(v))
    }

    // Mutable pointer to the field.
    pub fn mut_call(&mut self) -> &mut CallExpr {
        if let ::std::option::Option::Some(expr::Inner::Call(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::Call(CallExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Call(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_call(&mut self) -> CallExpr {
        if self.has_call() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::Call(v)) => v,
                _ => panic!(),
            }
        } else {
            CallExpr::new()
        }
    }

    // optional string string = 5;

    pub fn string(&self) -> &str {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::String(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::String(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.inner = ::std::option::Option::Some(expr::Inner::String(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(expr::Inner::String(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::String(::std::string::String::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::String(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::String(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional int64 int64 = 6;

    pub fn int64(&self) -> i64 {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Int64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int64(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_int64(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64(&mut self, v: i64) {
        self.inner = ::std::option::Option::Some(expr::Inner::Int64(v))
    }

    // optional int32 int32 = 7;

    pub fn int32(&self) -> i32 {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Int32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int32(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_int32(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Int32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int32(&mut self, v: i32) {
        self.inner = ::std::option::Option::Some(expr::Inner::Int32(v))
    }

    // optional float float = 8;

    pub fn float(&self) -> f32 {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Float(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_float(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: f32) {
        self.inner = ::std::option::Option::Some(expr::Inner::Float(v))
    }

    // optional bool bool = 9;

    pub fn bool(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Bool(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.inner = ::std::option::Option::Some(expr::Inner::Bool(v))
    }

    // optional .model.HouseExpr house = 10;

    pub fn house(&self) -> &HouseExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::House(ref v)) => v,
            _ => <HouseExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_house(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_house(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::House(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_house(&mut self, v: HouseExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::House(v))
    }

    // Mutable pointer to the field.
    pub fn mut_house(&mut self) -> &mut HouseExpr {
        if let ::std::option::Option::Some(expr::Inner::House(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::House(HouseExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::House(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_house(&mut self) -> HouseExpr {
        if self.has_house() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::House(v)) => v,
                _ => panic!(),
            }
        } else {
            HouseExpr::new()
        }
    }

    // optional .model.RoomExpr room = 11;

    pub fn room(&self) -> &RoomExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Room(ref v)) => v,
            _ => <RoomExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_room(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_room(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Room(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_room(&mut self, v: RoomExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::Room(v))
    }

    // Mutable pointer to the field.
    pub fn mut_room(&mut self) -> &mut RoomExpr {
        if let ::std::option::Option::Some(expr::Inner::Room(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::Room(RoomExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Room(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_room(&mut self) -> RoomExpr {
        if self.has_room() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::Room(v)) => v,
                _ => panic!(),
            }
        } else {
            RoomExpr::new()
        }
    }

    // optional .model.ControllerExpr controller = 12;

    pub fn controller(&self) -> &ControllerExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Controller(ref v)) => v,
            _ => <ControllerExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_controller(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Controller(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: ControllerExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::Controller(v))
    }

    // Mutable pointer to the field.
    pub fn mut_controller(&mut self) -> &mut ControllerExpr {
        if let ::std::option::Option::Some(expr::Inner::Controller(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::Controller(ControllerExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Controller(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_controller(&mut self) -> ControllerExpr {
        if self.has_controller() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::Controller(v)) => v,
                _ => panic!(),
            }
        } else {
            ControllerExpr::new()
        }
    }

    // optional .model.DisplayInterfaceExpr display_interface = 13;

    pub fn display_interface(&self) -> &DisplayInterfaceExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::DisplayInterface(ref v)) => v,
            _ => <DisplayInterfaceExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_display_interface(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_display_interface(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::DisplayInterface(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_display_interface(&mut self, v: DisplayInterfaceExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::DisplayInterface(v))
    }

    // Mutable pointer to the field.
    pub fn mut_display_interface(&mut self) -> &mut DisplayInterfaceExpr {
        if let ::std::option::Option::Some(expr::Inner::DisplayInterface(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::DisplayInterface(DisplayInterfaceExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::DisplayInterface(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_display_interface(&mut self) -> DisplayInterfaceExpr {
        if self.has_display_interface() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::DisplayInterface(v)) => v,
                _ => panic!(),
            }
        } else {
            DisplayInterfaceExpr::new()
        }
    }

    // optional .model.DeviceExpr device = 14;

    pub fn device(&self) -> &DeviceExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Device(ref v)) => v,
            _ => <DeviceExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Device(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: DeviceExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::Device(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device(&mut self) -> &mut DeviceExpr {
        if let ::std::option::Option::Some(expr::Inner::Device(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::Device(DeviceExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Device(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device(&mut self) -> DeviceExpr {
        if self.has_device() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::Device(v)) => v,
                _ => panic!(),
            }
        } else {
            DeviceExpr::new()
        }
    }

    // optional .model.WidgetExpr widget = 15;

    pub fn widget(&self) -> &WidgetExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Widget(ref v)) => v,
            _ => <WidgetExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_widget(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_widget(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Widget(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_widget(&mut self, v: WidgetExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::Widget(v))
    }

    // Mutable pointer to the field.
    pub fn mut_widget(&mut self) -> &mut WidgetExpr {
        if let ::std::option::Option::Some(expr::Inner::Widget(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::Widget(WidgetExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::Widget(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_widget(&mut self) -> WidgetExpr {
        if self.has_widget() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::Widget(v)) => v,
                _ => panic!(),
            }
        } else {
            WidgetExpr::new()
        }
    }

    // optional .model.IfExpr if = 16;

    pub fn if_(&self) -> &IfExpr {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::If(ref v)) => v,
            _ => <IfExpr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_if_(&mut self) {
        self.inner = ::std::option::Option::None;
    }

    pub fn has_if(&self) -> bool {
        match self.inner {
            ::std::option::Option::Some(expr::Inner::If(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_if(&mut self, v: IfExpr) {
        self.inner = ::std::option::Option::Some(expr::Inner::If(v))
    }

    // Mutable pointer to the field.
    pub fn mut_if(&mut self) -> &mut IfExpr {
        if let ::std::option::Option::Some(expr::Inner::If(_)) = self.inner {
        } else {
            self.inner = ::std::option::Option::Some(expr::Inner::If(IfExpr::new()));
        }
        match self.inner {
            ::std::option::Option::Some(expr::Inner::If(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_if_(&mut self) -> IfExpr {
        if self.has_if() {
            match self.inner.take() {
                ::std::option::Option::Some(expr::Inner::If(v)) => v,
                _ => panic!(),
            }
        } else {
            IfExpr::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "position",
            |m: &Expr| { &m.position },
            |m: &mut Expr| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RefExpr>(
            "ref",
            Expr::has_ref,
            Expr::ref_,
            Expr::mut_ref,
            Expr::set_ref,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LambdaExpr>(
            "lambda",
            Expr::has_lambda,
            Expr::lambda,
            Expr::mut_lambda,
            Expr::set_lambda,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CallExpr>(
            "call",
            Expr::has_call,
            Expr::call,
            Expr::mut_call,
            Expr::set_call,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string",
            Expr::has_string,
            Expr::string,
            Expr::set_string,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int64",
            Expr::has_int64,
            Expr::int64,
            Expr::set_int64,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int32",
            Expr::has_int32,
            Expr::int32,
            Expr::set_int32,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "float",
            Expr::has_float,
            Expr::float,
            Expr::set_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool",
            Expr::has_bool,
            Expr::bool,
            Expr::set_bool,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HouseExpr>(
            "house",
            Expr::has_house,
            Expr::house,
            Expr::mut_house,
            Expr::set_house,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RoomExpr>(
            "room",
            Expr::has_room,
            Expr::room,
            Expr::mut_room,
            Expr::set_room,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ControllerExpr>(
            "controller",
            Expr::has_controller,
            Expr::controller,
            Expr::mut_controller,
            Expr::set_controller,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DisplayInterfaceExpr>(
            "display_interface",
            Expr::has_display_interface,
            Expr::display_interface,
            Expr::mut_display_interface,
            Expr::set_display_interface,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeviceExpr>(
            "device",
            Expr::has_device,
            Expr::device,
            Expr::mut_device,
            Expr::set_device,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WidgetExpr>(
            "widget",
            Expr::has_widget,
            Expr::widget,
            Expr::mut_widget,
            Expr::set_widget,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, IfExpr>(
            "if",
            Expr::has_if,
            Expr::if_,
            Expr::mut_if,
            Expr::set_if,
        ));
        oneofs.push(expr::Inner::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Expr>(
            "Expr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Expr {
    const NAME: &'static str = "Expr";

    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(expr::Inner::Ref(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::Lambda(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::Call(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::House(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::Room(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::Controller(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::DisplayInterface(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::Device(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::Widget(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(expr::Inner::If(ref v)) = self.inner {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                18 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Ref(is.read_message()?));
                },
                26 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Lambda(is.read_message()?));
                },
                34 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Call(is.read_message()?));
                },
                42 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::String(is.read_string()?));
                },
                48 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Int64(is.read_int64()?));
                },
                56 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Int32(is.read_int32()?));
                },
                69 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Float(is.read_float()?));
                },
                72 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Bool(is.read_bool()?));
                },
                82 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::House(is.read_message()?));
                },
                90 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Room(is.read_message()?));
                },
                98 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Controller(is.read_message()?));
                },
                106 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::DisplayInterface(is.read_message()?));
                },
                114 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Device(is.read_message()?));
                },
                122 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::Widget(is.read_message()?));
                },
                130 => {
                    self.inner = ::std::option::Option::Some(expr::Inner::If(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &expr::Inner::Ref(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::Lambda(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::Call(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::String(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &expr::Inner::Int64(v) => {
                    my_size += ::protobuf::rt::int64_size(6, v);
                },
                &expr::Inner::Int32(v) => {
                    my_size += ::protobuf::rt::int32_size(7, v);
                },
                &expr::Inner::Float(v) => {
                    my_size += 1 + 4;
                },
                &expr::Inner::Bool(v) => {
                    my_size += 1 + 1;
                },
                &expr::Inner::House(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::Room(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::Controller(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::DisplayInterface(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::Device(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::Widget(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &expr::Inner::If(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.inner {
            match v {
                &expr::Inner::Ref(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &expr::Inner::Lambda(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &expr::Inner::Call(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &expr::Inner::String(ref v) => {
                    os.write_string(5, v)?;
                },
                &expr::Inner::Int64(v) => {
                    os.write_int64(6, v)?;
                },
                &expr::Inner::Int32(v) => {
                    os.write_int32(7, v)?;
                },
                &expr::Inner::Float(v) => {
                    os.write_float(8, v)?;
                },
                &expr::Inner::Bool(v) => {
                    os.write_bool(9, v)?;
                },
                &expr::Inner::House(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &expr::Inner::Room(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &expr::Inner::Controller(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &expr::Inner::DisplayInterface(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &expr::Inner::Device(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &expr::Inner::Widget(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &expr::Inner::If(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Expr {
        Expr::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.inner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Expr {
        static instance: Expr = Expr {
            position: ::protobuf::MessageField::none(),
            inner: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Expr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Expr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Expr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Expr`
pub mod expr {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:model.Expr.inner)
    pub enum Inner {
        // @@protoc_insertion_point(oneof_field:model.Expr.ref)
        Ref(super::RefExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.lambda)
        Lambda(super::LambdaExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.call)
        Call(super::CallExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.string)
        String(::std::string::String),
        // @@protoc_insertion_point(oneof_field:model.Expr.int64)
        Int64(i64),
        // @@protoc_insertion_point(oneof_field:model.Expr.int32)
        Int32(i32),
        // @@protoc_insertion_point(oneof_field:model.Expr.float)
        Float(f32),
        // @@protoc_insertion_point(oneof_field:model.Expr.bool)
        Bool(bool),
        // @@protoc_insertion_point(oneof_field:model.Expr.house)
        House(super::HouseExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.room)
        Room(super::RoomExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.controller)
        Controller(super::ControllerExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.display_interface)
        DisplayInterface(super::DisplayInterfaceExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.device)
        Device(super::DeviceExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.widget)
        Widget(super::WidgetExpr),
        // @@protoc_insertion_point(oneof_field:model.Expr.if)
        If(super::IfExpr),
    }

    impl ::protobuf::Oneof for Inner {
    }

    impl ::protobuf::OneofFull for Inner {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Expr as ::protobuf::MessageFull>::descriptor().oneof_by_name("inner").unwrap()).clone()
        }
    }

    impl Inner {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Inner>("inner")
        }
    }
}

// @@protoc_insertion_point(message:model.Module)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Module {
    // message fields
    // @@protoc_insertion_point(field:model.Module.imports)
    pub imports: ::std::collections::HashMap<::std::string::String, Module>,
    // @@protoc_insertion_point(field:model.Module.body)
    pub body: ::protobuf::MessageField<Expr>,
    // special fields
    // @@protoc_insertion_point(special_field:model.Module.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "imports",
            |m: &Module| { &m.imports },
            |m: &mut Module| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Expr>(
            "body",
            |m: &Module| { &m.body },
            |m: &mut Module| { &mut m.body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Module>(
            "Module",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Module {
    const NAME: &'static str = "Module";

    fn is_initialized(&self) -> bool {
        if self.body.is_none() {
            return false;
        }
        // TODO: check map values are initialized
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.imports.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.body)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.imports {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.imports {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Module {
        Module::new()
    }

    fn clear(&mut self) {
        self.imports.clear();
        self.body.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Module {
        static instance: ::protobuf::rt::Lazy<Module> = ::protobuf::rt::Lazy::new();
        instance.get(Module::new)
    }
}

impl ::protobuf::MessageFull for Module {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Module").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17OpenControllerLib.proto\x12\x05model\"{\n\tHouseExpr\x12.\n\x0cdis\
    play_name\x18\x01\x20\x02(\x0b2\x0b.model.ExprR\x0bdisplayName\x12\x1b\n\
    \x02id\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\x02id\x12!\n\x05rooms\x18\
    \x03\x20\x03(\x0b2\x0b.model.ExprR\x05rooms\"\xa7\x01\n\x08RoomExpr\x12\
    \x1b\n\x02id\x18\x01\x20\x02(\x0b2\x0b.model.ExprR\x02id\x12.\n\x0cdispl\
    ay_name\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\x0bdisplayName\x12-\n\x0bc\
    ontrollers\x18\x03\x20\x03(\x0b2\x0b.model.ExprR\x0bcontrollers\x12\x1f\
    \n\x04icon\x18\x04\x20\x01(\x0b2\x0b.model.ExprR\x04icon\"\xc5\x01\n\x0e\
    ControllerExpr\x12\x1b\n\x02id\x18\x01\x20\x02(\x0b2\x0b.model.ExprR\x02\
    id\x12.\n\x0cdisplay_name\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\x0bdispl\
    ayName\x12,\n\x0bbrand_color\x18\x03\x20\x01(\x0b2\x0b.model.ExprR\nbran\
    dColor\x128\n\x11display_interface\x18\x04\x20\x01(\x0b2\x0b.model.ExprR\
    \x10displayInterface\"=\n\x14DisplayInterfaceExpr\x12%\n\x07widgets\x18\
    \x01\x20\x03(\x0b2\x0b.model.ExprR\x07widgets\"\x8f\x01\n\nDeviceExpr\
    \x128\n\x07lambdas\x18\x01\x20\x03(\x0b2\x1e.model.DeviceExpr.LambdasEnt\
    ryR\x07lambdas\x1aG\n\x0cLambdasEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12!\n\x05value\x18\x02\x20\x01(\x0b2\x0b.model.ExprR\x05valu\
    e:\x028\x01\"\xd5\x01\n\nWidgetExpr\x12\x1f\n\x0bwidget_type\x18\x02\x20\
    \x02(\tR\nwidgetType\x125\n\x06params\x18\x03\x20\x03(\x0b2\x1d.model.Wi\
    dgetExpr.ParamsEntryR\x06params\x12'\n\x08children\x18\x04\x20\x03(\x0b2\
    \x0b.model.ExprR\x08children\x1aF\n\x0bParamsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12!\n\x05value\x18\x02\x20\x01(\x0b2\x0b.model.\
    ExprR\x05value:\x028\x01\"\x1b\n\x07RefExpr\x12\x10\n\x03ref\x18\x01\x20\
    \x02(\tR\x03ref\"E\n\nLambdaExpr\x12\x12\n\x04args\x18\x01\x20\x03(\tR\
    \x04args\x12#\n\x06return\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\x06retur\
    n\"R\n\x08CallExpr\x12%\n\x07calling\x18\x01\x20\x02(\x0b2\x0b.model.Exp\
    rR\x07calling\x12\x1f\n\x04args\x18\x02\x20\x03(\x0b2\x0b.model.ExprR\
    \x04args\"R\n\x04Elif\x12)\n\tcondition\x18\x01\x20\x02(\x0b2\x0b.model.\
    ExprR\tcondition\x12\x1f\n\x04then\x18\x02\x20\x02(\x0b2\x0b.model.ExprR\
    \x04then\"\x96\x01\n\x06IfExpr\x12)\n\tcondition\x18\x01\x20\x02(\x0b2\
    \x0b.model.ExprR\tcondition\x12\x1f\n\x04then\x18\x02\x20\x02(\x0b2\x0b.\
    model.ExprR\x04then\x12\x1f\n\x04elif\x18\x03\x20\x03(\x0b2\x0b.model.El\
    ifR\x04elif\x12\x1f\n\x04else\x18\x04\x20\x02(\x0b2\x0b.model.ExprR\x04e\
    lse\"J\n\x08Position\x12\x12\n\x04file\x18\x01\x20\x02(\tR\x04file\x12\
    \x12\n\x04line\x18\x02\x20\x02(\x05R\x04line\x12\x16\n\x06column\x18\x03\
    \x20\x02(\x05R\x06column\"\xfd\x04\n\x04Expr\x12+\n\x08position\x18\x01\
    \x20\x01(\x0b2\x0f.model.PositionR\x08position\x12\"\n\x03ref\x18\x02\
    \x20\x01(\x0b2\x0e.model.RefExprH\0R\x03ref\x12+\n\x06lambda\x18\x03\x20\
    \x01(\x0b2\x11.model.LambdaExprH\0R\x06lambda\x12%\n\x04call\x18\x04\x20\
    \x01(\x0b2\x0f.model.CallExprH\0R\x04call\x12\x18\n\x06string\x18\x05\
    \x20\x01(\tH\0R\x06string\x12\x16\n\x05int64\x18\x06\x20\x01(\x03H\0R\
    \x05int64\x12\x16\n\x05int32\x18\x07\x20\x01(\x05H\0R\x05int32\x12\x16\n\
    \x05float\x18\x08\x20\x01(\x02H\0R\x05float\x12\x14\n\x04bool\x18\t\x20\
    \x01(\x08H\0R\x04bool\x12(\n\x05house\x18\n\x20\x01(\x0b2\x10.model.Hous\
    eExprH\0R\x05house\x12%\n\x04room\x18\x0b\x20\x01(\x0b2\x0f.model.RoomEx\
    prH\0R\x04room\x127\n\ncontroller\x18\x0c\x20\x01(\x0b2\x15.model.Contro\
    llerExprH\0R\ncontroller\x12J\n\x11display_interface\x18\r\x20\x01(\x0b2\
    \x1b.model.DisplayInterfaceExprH\0R\x10displayInterface\x12+\n\x06device\
    \x18\x0e\x20\x01(\x0b2\x11.model.DeviceExprH\0R\x06device\x12+\n\x06widg\
    et\x18\x0f\x20\x01(\x0b2\x11.model.WidgetExprH\0R\x06widget\x12\x1f\n\
    \x02if\x18\x10\x20\x01(\x0b2\r.model.IfExprH\0R\x02ifB\x07\n\x05inner\"\
    \xaa\x01\n\x06Module\x124\n\x07imports\x18\x01\x20\x03(\x0b2\x1a.model.M\
    odule.ImportsEntryR\x07imports\x12\x1f\n\x04body\x18\x02\x20\x02(\x0b2\
    \x0b.model.ExprR\x04body\x1aI\n\x0cImportsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12#\n\x05value\x18\x02\x20\x01(\x0b2\r.model.Module\
    R\x05value:\x028\x01BR\n&com.pjtsearch.opencontroller_lib_protoP\x01Z&pj\
    tsearch.com/opencontroller_lib_proto\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(14);
            messages.push(HouseExpr::generated_message_descriptor_data());
            messages.push(RoomExpr::generated_message_descriptor_data());
            messages.push(ControllerExpr::generated_message_descriptor_data());
            messages.push(DisplayInterfaceExpr::generated_message_descriptor_data());
            messages.push(DeviceExpr::generated_message_descriptor_data());
            messages.push(WidgetExpr::generated_message_descriptor_data());
            messages.push(RefExpr::generated_message_descriptor_data());
            messages.push(LambdaExpr::generated_message_descriptor_data());
            messages.push(CallExpr::generated_message_descriptor_data());
            messages.push(Elif::generated_message_descriptor_data());
            messages.push(IfExpr::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(Expr::generated_message_descriptor_data());
            messages.push(Module::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
